#!/bin/sh
# Shell functions for most initialization scripts

die() {
	echo >&2 "$*";
	read -p 'Hit enter to continue.'
	exit 1;
}

debug(){
  echo >&2 "$*";
  read -p 'Hit enter to continue.'
}

error() {
	echo >&2 "$*";
  exit 1;
}

warn() {
	echo >&2 "$*";
}

recovery() {
	echo >&2 "!!!!! $*"

	# Remove any temporary secret files that might be hanging around
	# but recreate the directory so that new tools can use it.
	shred -n 10 -z -u /tmp/secret/* 2> /dev/null
	rm -rf /tmp/secret
	mkdir -p /tmp/secret

	# ensure /tmp/config exists for recovery scripts that depend on it
	touch /tmp/config

	if [ "$CONFIG_TPM" = y ]; then
		tpm extend -ix 4 -ic recovery
	fi
	echo >&2 "!!!!! Starting recovery shell"
	sleep 1

	if [ -x /bin/setsid ]; then
		exec /bin/setsid -c /bin/ash
	else
		exec /bin/ash
	fi
}

pause_recovery() {
	read -p 'Hit enter to proceed to recovery shell:'
	recovery $*
}

pcrs() {
	head -8 /sys/class/tpm/tpm0/pcrs
}

confirm_totp()
{
	prompt="$1"
	last_half=X
	unset totp_confirm

	while true; do

		# update the TOTP code every thirty seconds
		date=`date "+%Y-%m-%d %H:%M:%S"`
		seconds=`date "+%s"`
		half=`expr \( $seconds % 60 \) / 30`
		if [ "$CONFIG_TPM" != y ]; then
			TOTP="NO TPM"
		elif [ "$half" != "$last_half" ]; then
			last_half=$half;
			TOTP=`unseal-totp` \
			|| recovery "TOTP code generation failed"
		fi

		echo -n "$date $TOTP: "

		# read the first character, non-blocking
		read \
			-t 1 \
			-n 1 \
			-s \
			-p "$prompt" \
			totp_confirm \
		&& break

		# nothing typed, redraw the line
		echo -ne '\r'
	done

	# clean up with a newline
	echo
}

enable_usb()
{
	if [ "$CONFIG_LINUX_USB_COMPANION_CONTROLLER" = y ]; then
		if ! lsmod | grep -q uhci_hcd; then
			insmod /lib/modules/uhci-hcd.ko \
			|| die "uhci_hcd: module load failed"
		fi
		if ! lsmod | grep -q ohci_hcd; then
			insmod /lib/modules/ohci-hcd.ko \
			|| die "ohci_hcd: module load failed"
		fi
		if ! lsmod | grep -q ohci_pci; then
			insmod /lib/modules/ohci-pci.ko \
			|| die "ohci_pci: module load failed"
		fi
	fi
	if ! lsmod | grep -q ehci_hcd; then
		insmod /lib/modules/ehci-hcd.ko \
		|| die "ehci_hcd: module load failed"
	fi
	if ! lsmod | grep -q ehci_pci; then
		insmod /lib/modules/ehci-pci.ko \
		|| die "ehci_pci: module load failed"
	fi
	if ! lsmod | grep -q xhci_hcd; then
		insmod /lib/modules/xhci-hcd.ko \
		|| die "xhci_hcd: module load failed"
	fi
	if ! lsmod | grep -q xhci_pci; then
		insmod /lib/modules/xhci-pci.ko \
		|| die "xhci_pci: module load failed"
		sleep 2
	fi
}

file_selector() {
  FILE=""
  FILE_LIST=$1
  MENU_MSG=${2:-"Choose the file"}
  # create file menu options
  if [ $(cat "$FILE_LIST" | wc -l) -gt 0 ]; then
    option=""
    while [ -z "$option" ]
    do
      MENU_OPTIONS=""
      n=0
      while read option
      do
        n=$(expr $n + 1)
        option=$(echo "$option" | tr " " "_")
        MENU_OPTIONS="$MENU_OPTIONS $n ${option}"
      done < $FILE_LIST

      MENU_OPTIONS="$MENU_OPTIONS a Abort"
      whiptail --clear --title "Select your File" \
        --menu "${MENU_MSG} [1-$n, a to abort]:" 20 120 8 \
        -- $MENU_OPTIONS \
        2>/tmp/whiptail || die "Aborting"

      option_index=$(cat /tmp/whiptail)

      if [ "$option_index" = "a" ]; then
        option="a"
        return
      fi

      option=$(head -n "$option_index" "$FILE_LIST" | tail -1)
      if [ "$option" == "a" ]; then
        return
      fi
    done
    if [ -n "$option" ]; then
      FILE=$option
    fi
  else
    whiptail $CONFIG_ERROR_BG_COLOR --title 'ERROR: No Files Found' \
      --msgbox "No Files found matching the pattern. Aborting." 16 60
    exit 1
  fi
}

mount_boot()
{
  # Mount local disk if it is not already mounted
  if ! grep -q /boot /proc/mounts ; then
    mount -o ro /boot \
      || recovery "Unable to mount /boot from $CONFIG_BOOT_DEV"
  fi
}

confirm_gpg_card()
{
	read \
		-n 1 \
		-p "Please confirm that your GPG card is inserted [Y/n]: " \
		card_confirm
	echo

	if [ "$card_confirm" != "y" \
		-a "$card_confirm" != "Y" \
		-a -n "$card_confirm" ] \
	; then
		die "gpg card not confirmed"
	fi

	# setup the USB so we can reach the GPG card
	enable_usb

	gpg --card-status \
	|| die "gpg card read failed"
}

check_tpm_counter()
{
  LABEL=${2:-3135106223}
	# if the /boot.hashes file already exists, read the TPM counter ID
	# from it.
	if [ -r "$1" ]; then
		TPM_COUNTER=`grep counter- "$1" | cut -d- -f2`
  else 
    warn "$1 does not exist; creating new TPM counter"
    if [ -z "$oem_TPM_Owner_Password" ]; then
		  read -s -p "TPM Owner password: " tpm_password
		  echo
    else
      tpm_password=$(echo -n "$oem_TPM_Owner_Password")
    fi

		tpm counter_create \
			-pwdo "$tpm_password" \
			-pwdc '' \
			-la $LABEL \
		| tee /tmp/counter \
		|| die "Unable to create TPM counter"
		TPM_COUNTER=`cut -d: -f1 < /tmp/counter`
	fi

	if [ -z "$TPM_COUNTER" ]; then
		die "$1: TPM Counter not found?"
	fi
}

read_tpm_counter()
{
	tpm counter_read -ix "$1" | tee "/tmp/counter-$1" \
	|| die "Counter read failed"
}

increment_tpm_counter()
{
	tpm counter_increment -ix "$1" -pwdc '' \
		| tee /tmp/counter-$1 \
	|| die "Counter increment failed"
}

check_config() {
	if [ ! -d /tmp/kexec ]; then
		mkdir /tmp/kexec \
		|| die 'Failed to make kexec tmp dir'
	else
		rm -rf /tmp/kexec/* \
		|| die 'Failed to empty kexec tmp dir'
	fi

	if [ ! -r $1/kexec.sig ]; then
		return
	fi

	if [ `find $1/kexec*.txt | wc -l` -eq 0 ]; then
		return
	fi

	if [ "$2" != "force" ]; then
		if ! sha256sum `find $1/kexec*.txt` | gpgv $1/kexec.sig - ; then
			die 'Invalid signature on kexec boot params. Investigate/Update checksums and sign all files in /boot.'
      #TODO: Show which files failed integrity check!
		fi
	fi

	echo "+++ Found verified kexec boot params"
	cp $1/kexec*.txt /tmp/kexec \
	|| die "Failed to copy kexec boot params to tmp"
}

preserve_rom() {
	new_rom="$1"
	old_files=`cbfs -t 50 -l 2>/dev/null | grep "^heads/"`

	for old_file in `echo $old_files`; do
		new_file=`cbfs -o $1 -l | grep -x $old_file`
		if [ -z "$new_file" ]; then
			echo "+++ Adding $old_file to $1"
			cbfs -t 50 -r $old_file >/tmp/rom.$$ \
			|| die "Failed to read cbfs file from ROM"
			cbfs -o $1 -a $old_file -f /tmp/rom.$$ \
			|| die "Failed to write cbfs file to new ROM file"
		fi
	done
}
replace_config() {
	CONFIG_FILE=$1
	CONFIG_OPTION=$2
	NEW_SETTING=$3

	touch $CONFIG_FILE
# first pull out the existing option from the global config and place in a tmp file
	awk "gsub(\"^export ${CONFIG_OPTION}=.*\",\"export ${CONFIG_OPTION}=\\\"${NEW_SETTING}\\\"\")" /tmp/config > ${CONFIG_FILE}.tmp
	awk "gsub(\"^${CONFIG_OPTION}=.*\",\"${CONFIG_OPTION}=\\\"${NEW_SETTING}\\\"\")" /tmp/config >> ${CONFIG_FILE}.tmp

# then copy any remaining settings from the existing config file, minus the option you changed
	grep -v "^export ${CONFIG_OPTION}=" ${CONFIG_FILE} | grep -v "^${CONFIG_OPTION}=" >> ${CONFIG_FILE}.tmp || true
  sort ${CONFIG_FILE}.tmp | uniq > ${CONFIG_FILE}
	rm -f ${CONFIG_FILE}.tmp
}
combine_configs() {
	cat /etc/config* > /tmp/config
}
read_oem_file()
{
  #TODO: check if /boot/oem contains past USB disk and automount it. see tracing TODO below
  oem_name=$(grep "oem_name" /boot/oem | awk -F '=' {'print $2'})
  if [ -n "$oem_name" ]; then
    export oem_name="$oem_name"
  else
    oem_name="your OEM"
    export oem_name="$oem_name"
  fi

  echo "Mounting USB drive to provision OEM reownership from /media/oem-provisioning..."
  /bin/mount-usb rw || warn "Unable to mount USB device. Continuing"
  if [ -e /media/oem-provisioning ]; then
    #TODO: trace mounted USB disk into /boot/oem

    oem_gpg_Admin_PIN=$(grep "^oem_gpg_Admin_PIN=" /media/oem-provisioning | cut -d "=" -f2)
    oem_gpg_Admin_PIN_count=$(echo "$oem_gpg_Admin_PIN" | wc -l )
    if [ -n "$oem_gpg_Admin_PIN" ]; then
      if [ $oem_gpg_Admin_PIN_count -eq 1 ]; then
        export oem_gpg_Admin_PIN="$oem_gpg_Admin_PIN"
      elif [ $oem_gpg_Admin_PIN_count -gt 1 ]; then
        warn "Multiple 'oem_gpg_Admin_PIN=' statements found. None retained."
        unset oem_gpg_Admin_PIN
        error=1
      fi
    else
      warn "No 'oem_gpg_Admin_PIN=' statement found."
      prompt_user_provisioning=1
    fi

    oem_gpg_User_PIN=$(grep "^oem_gpg_User_PIN=" /media/oem-provisioning | cut -d "=" -f2) 
    oem_gpg_User_PIN_count=$(echo "$oem_gpg_User_PIN" | wc -l )
    if [ -n "$oem_gpg_User_PIN" ]; then
      if [ $oem_gpg_User_PIN_count -eq 1 ]; then
        export oem_gpg_User_PIN="$oem_gpg_User_PIN"
      elif [ $oem_gpg_User_PIN_count -gt 1 ]; then
        warn "Multiple 'oem_gpg_Admin_PIN=' statements found. None retained."
        unset oem_gpg_User_PIN
        error=1
      fi
    else
      warn "No 'oem_gpg_User_PIN=' statement found."
      prompt_user_provisioning=1
    fi

    oem_gpg_real_name=$(grep "^oem_gpg_real_name=" /media/oem-provisioning | cut -d "=" -f2)
    oem_gpg_real_name_count=$(echo "$oem_gpg_real_name" | wc -l )
    if [ -n "$oem_gpg_real_name" ]; then
      if [ $oem_gpg_real_name_count -eq 1 ]; then
        export oem_gpg_real_name="$oem_gpg_real_name"
      elif [ $oem_gpg_real_name_count -gt 1 ]; then
        warn "Multiple 'oem_gpg_real_name=' statements found. None retained."
        unset oem_gpg_real_name
        error=1
      fi
    else
      warn "No 'oem_gpg_real_name=' statement found."
      prompt_user_provisioning=1
    fi

    oem_gpg_email=$(grep "^oem_gpg_email=" /media/oem-provisioning | cut -d "=" -f2)
    oem_gpg_email_count=$(echo "$oem_gpg_email" | wc -l )
    if [ -n "$oem_gpg_email" ]; then
      if [ $oem_gpg_email_count -eq 1 ]; then
        export oem_gpg_email="$oem_gpg_email"
      elif [ $oem_gpg_email_count -gt 1 ]; then
        warn "Multiple 'oem_gpg_email=' statements found. None retained."
        unset oem_gpg_email
        error=1
      fi
    else
      warn "No 'oem_gpg_email=' statement found."
      prompt_user_provisioning=1
    fi

    oem_gpg_comment=$(grep "^oem_gpg_comment=" /media/oem-provisioning | cut -d "=" -f2)
    oem_gpg_comment_count=$(echo "$oem_gpg_comment" | wc -l )
    if [ -n "$oem_gpg_comment" ]; then
      if [ $oem_gpg_comment_count -eq 1 ]; then
        export oem_gpg_comment="$oem_gpg_comment"
      elif [ $oem_gpg_comment -gt 1 ]; then
        warn "Multiple 'oem_gpg_comment=' statements found. None retained."
        unset oem_gpg_comment
        error=1
      fi
    else
      warn "No 'oem_gpg_comment=' statement found."
      prompt_user_provisioning=1
    fi

    oem_luks_actual_Disk_Recovery_Key=$(grep "^oem_luks_actual_Disk_Recovery_Key=" /media/oem-provisioning | cut -d "=" -f2)
    oem_luks_actual_Disk_Recovery_Key_count=$(echo "$oem_luks_actual_Disk_Recovery_Key" | wc -l )
    if [ -n "$oem_luks_actual_Disk_Recovery_Key" ]; then
      if [ $oem_luks_actual_Disk_Recovery_Key_count -eq 1 ]; then
        export oem_luks_actual_Disk_Recovery_Key="$oem_luks_actual_Disk_Recovery_Key"
      elif [ $oem_luks_actual_Disk_Recovery_Key_count -gt 1 ]; then
        warn "Multiple 'oem_luks_actual_Disk_Recovery_Key=' statements found. None retained."
        unset oem_luks_actual_Disk_Recovery_Key
        error=1
      fi
    else
      warn "No 'oem_luks_actual_Disk_Recovery_Key=' statement found."
      prompt_user_provisioning=1
    fi

    oem_luks_new_Disk_Recovery_Key=$(grep "^oem_luks_new_Disk_Recovery_Key=" /media/oem-provisioning | cut -d "=" -f2)
    oem_luks_new_Disk_Recovery_Key_count=$(echo "$oem_luks_new_Disk_Recovery_Key" | wc -l )
    if [ -n "$oem_luks_new_Disk_Recovery_Key" ]; then
      if [ $oem_luks_new_Disk_Recovery_Key_count -eq 1 ]; then
        export oem_luks_new_Disk_Recovery_Key="$oem_luks_new_Disk_Recovery_Key"
      elif [ $oem_luks_new_Disk_Recovery_Key_count -gt 1 ]; then
        warn "Multiple 'oem_luks_new_Disk_Recovery_Key=' statements found. None retained."
        unset oem_luks_new_Disk_Recovery_Key
        error=1
      fi
    else
      warn "No 'oem_luks_new_Disk_Recovery_Key=' statement found."
      prompt_user_provisioning=1
    fi

    oem_luks_Disk_Unlock_Key=$(grep "^oem_luks_Disk_Unlock_Key=" /media/oem-provisioning | cut -d "=" -f2)
    oem_luks_Disk_Unlock_Key_count=$(echo "$oem_luks_Disk_Unlock_Key" | wc -l )
    if [ -n "$oem_luks_Disk_Unlock_Key" ]; then
      if [ $oem_luks_Disk_Unlock_Key_count -eq 1 ]; then
        export oem_luks_Disk_Unlock_Key="$oem_luks_Disk_Unlock_Key"
      elif [ $oem_luks_Disk_Unlock_Key_count -gt 1 ]; then
        warn "Multiple 'oem_luks_Disk_Unlock_Key=' statements found. None retained."
        unset oem_luks_Disk_Unlock_Key
        error=1
      fi
    else
      warn "No 'oem_luks_Disk_Unlock_Key=' statement found."
      prompt_user_provisioning=1
    fi

    oem_TPM_Owner_Password=$(grep "^oem_TPM_Owner_Password=" /media/oem-provisioning | cut -d "=" -f2)
    oem_TPM_Owner_Password_count=$(echo "$oem_TPM_Owner_Password" | wc -l )
    if [ -n "$oem_TPM_Owner_Password" ]; then
      if [ $oem_TPM_Owner_Password_count -eq 1 ]; then
        export oem_TPM_Owner_Password="$oem_TPM_Owner_Password"
      elif [ $oem_TPM_Owner_Password_count -gt 1 ]; then
        warn "Multiple 'oem_TPM_Owner_Password=' statements found. None retained."
        unset oem_TPM_Owner_Password
        error=1
      fi
    else
      warn "No 'oem_TPM_Owner_Password=' statement found."
      prompt_user_provisioning=1
    fi

    if [ -n $error ] && [ "$error" -eq 1 ]; then
      recovery "Please run 'vi /media/oem-provisioning' to correct previous warnings. ('i': insert, modify, 'Esc' key, then ':wq', 'Enter' key, then 'unmount /media' and 'reboot'."
    fi

    if [ -n $prompt_user_provisioning ] && [ "$prompt_user_provisioning" -eq 1 ];then
      #TODO prompt for provisioning of unfilled variables
      #TODO: Put provisioning tracker into /boot/oem
      #TODO: Put /media/provisioning provisioning partition tracker into /boot/oem
      
      for to_provision in oem_gpg_Admin_PIN oem_gpg_User_PIN oem_gpg_real_name oem_gpg_email oem_gpg_comment oem_luks_actual_Disk_Recovery_Key oem_luks_new_Disk_Recovery_Key oem_luks_Disk_Unlock_Key oem_TPM_Owner_Password
      do
        provisioned_value=$(eval echo \$$to_provision)
        #debug "1-to_provision = $to_provision"
        #debug "2-indirector = $provisioned_value"
       
        #count_str="_count" 
        #to_provision_count="$to_provision$count_str"
				#to_provision_count_value=$(eval echo \$$to_provision_count)
        
        #We don't need that. We can check existence of $provisioned_value 
        #debug "3-to_provision_count = $to_provision_count"
				#debug "4-to_provision_count_value= $to_provision_count_value"

        if [ -z "$provisioned_value" ];then

          echo "$to_provision is not set."

          if [ "$to_provision" == "oem_gpg_Admin_PIN" ] ;then
            echo "We have limitations for Admin Pin: minimal 8 characters, no space."
            echo "There is no need to have a super strong passphrase here, it will be locked after 3 bad attempts in the GPG smartcard."
            echo "Suggested length: 2 random words diceware passphrase."
            echo "Chosen GPG Admin PIN will be requested from you inside of Heads to seal HOTP firmware integrity measurements."
            echo "Outside of Heads, your GPG User PIN will be prompted from you to sign/encrypt/authenticate with your GPG card."
            passphrase=$(diceware-eff.sh 2 UpperFirstLetter Nospace)
            #TODO:validate user choice
            export oem_gpg_Admin_PIN=$passphrase
            debug "oem_gpg_Admin_PIN=$oem_gpg_Admin_PIN"
          fi
          if [ "$to_provision" == "oem_gpg_User_PIN" ] ;then
            echo "We have limitations for GPG Admin Pin: minimal 6 characters."
            echo "There is no need to have a super strong passphrase here, it will be locked after 3 bad attempts in the GPG smartcard."
            echo "Suggested length: 2 random words diceware passphrase."
            echo "Chosen GPG User PIN will be requested from you from Heads each time a /boot configuration change is detected so you can validate it originated from you. From a QubesOS perspective, upgrading AdminVM (dom0) will most probably result in Heads requesting you to sign /boot integrity changes."
            echo "Outside of Heads, the chosen GPG User PIN will be prompted from you to sign/encrypt/authenticate with your GPG card."
            passphrase=$(diceware-eff.sh 2 UpperFirstLetter Nospace)
            export oem_gpg_User_PIN=$passphrase
            debug "oem_gpg_User_PIN=$oem_gpg_User_PIN"
          fi
          if [ "$to_provision" == "oem_luks_actual_Disk_Recovery_Key" ]; then
            echo "The actual LUKS Recovery Key passphrase was provided to you from $oem_name."
            echo "The actual LUKS Recovery Key passphrase is used to decrypt both USB and internal disk until reencrypted."
            read -s -r -p "Please enter LUKS Recovery Key passphrase provided by $oem_name:" oem_luks_actual_Disk_Recovery_Key
            #TODO: Validate that something was entered
            echo
            debug "oem_luks_actual_Disk_Recovery_Key=$oem_luks_actual_Disk_Recovery_Key"
            #TODO: actual should be replaced by new LUKS recovery key after reencryption.
          fi
          if [ "$to_provision" == "oem_luks_new_Disk_Recovery_Key" ]; then
            echo "Chosen new LUKS recovery Key passphrase needs to be remembered of you at all time."
            echo "If forgotten, the content of both $oem_name shipped USB disk and computer internal disk will be lost forever."
            echo "It is suggested that you choose a diceware passphrase of 6+ words."
            #TODO replicate this with validation
            password=$(diceware-eff.sh 7 UpperFirstLetter Nospace)
            export oem_luks_new_Disk_Recovery_Key="$password"
            debug "oem_luks_new_Disk_Recovery_Key=$oem_luks_new_Disk_Recovery_Key"

          fi
          if [ "$to_provision" == "oem_luks_Disk_Unlock_Key" ] && [ "$CONFIG_TPM" == "y" ] && [ "$CONFIG_OFFER_TPM_LUKS_DISK_UNLOCK_KEY" == "y" ]; then
            echo "Chosen LUKS Disk Unlock Key will be requested at each boot until the next OS boot default."
            echo "As opposed to the Disk Recovery Key passphrase, the Disk Unlock Key passphrase can be of a smaller length."
            echo "A diceware randomly selected passphrase of 3 words is enough, considering that the TPM is rate limiting the attempts."
            echo "Heads will prompt the user to boot with the Disk Recovery passphrase after 3 failed attempts on each reboot."
            echo
            echo "The Chosen LUKS Disk Unlock Key is an additional security measure of Heads, which permits disk decryption only if the firmware measurements valid."
            echo "As a consequence, the Disk Unlock Key passphrase is bound to this computer and this computer only."
            echo "As a result, someone cloning your disk and trying to decrypt its content by typing this passphrase will be unsuccessful."
            echo "If forgotten, no problem. Select a new boot default and you will be prompted to enter chosen Disk Recovery Key Passphrase prior to defining a new Disk Unlock Key passphrase."
            password=$(diceware-eff.sh 3 UpperFirstLetter Nospace)
            export oem_luks_Disk_Unlock_Key="$password"
            debug "oem_luks_Disk_Unlock_Key=$oem_luks_Disk_Unlock_Key"
          fi
          if [ "$to_provision" == "oem_TPM_Owner_Password" ] && [ "$CONFIG_TPM" == "y" ]; then
            echo "Chosen TPM Owner Password will never be requested from Heads but in the reownership process to initialize it."
            echo "A diceware randomly selected passphrase of 2 words is enough."
            echo "It is recommended to reuse GPG Admin Passphrase/Password here, to not unecessarily multiply secrets to remember."
            oem_TPM_Owner_Password="$oem_gpg_Admin_PIN"
            #TODO: validate if ok with user, else generate
            #password=$(diceware-eff.sh 2 UpperFirstLetter Nospace)
            export oem_TPM_Owner_Password="$oem_TPM_Owner_Password"
            debug "oem_TPM_Owner_Password=$oem_TPM_Owner_Password"
          fi
        else
          echo "$to_provision is $provisioned_value."
        fi
      done

      recovery "this is where we would prompt user to provisidon once automatic provisioning of secrets in the EOM reownership Wizard."
    
      #Could be a for loop of all undefined variables?
        #Do prompt of specifc constraints
            #GPG Admin: no space. 
            #Admin PIN: >8 chars. User Pins > 6 chars
          #GPG email format validation
          #GPG Name > 5 char < 30
        #Validate double prompt validated input
        #Store by appending to /media/oem-provisioning
    fi

    export oem_configuration_read=1
    umount /media
  fi
}

check_onboarding_progress()
{
  mount_boot
  if [ -e /boot/oem ]; then
    res=$(grep onboarding /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      #Show Onboarding menu once.
      whiptail --title 'Hardware reownership Wizard' --msgbox \
       "The received hardware is currently owned by $oem_name.\nWe will change that.\n\nThis Wizard will otherwise make you own your own hardware by:\n1-Reencrypting encrypted drive content (LUKS container)\n2-Changing LUKS Disk Recovery Key and it's passphrase\n3-Resetting your Librem Key/Nitrokey Pro v2 to factory defaults\n4-Setting User and Admin PINs into your Librem Key/NitroKey\n5-Generating keys in it, exporting public key and\n importing it in the ROM prior to reprogramming the SPI flash with it\n6-Taking integrity measures of all /boot files and sign the resulting\n checksum file with your Librem Key/Nitrokey Pro\n7-Reowning your Trusted Platform Module (TPM)\n\nScan the QR Code with an OTP app only after Reset the TPM last phase.\n\nHit Enter to continue." 20 20
      whiptail --title 'Hardware reownership Wizard' --msgbox \
       "On the next screen, MAKE SURE THAT THE HOTP CODE IS: 'Success'\n\nIf it's not, reboot your hardware with your Librem/Nitrokey inserted.\n\nIf the HOTP code is still invalid, your hardware may been tampered with in\ntransit. Contact $oem_name." 20 20
      totp_confirm="O"
      echo $totp_confirm > /tmp/whiptail
      mount -o remount,rw /boot
      echo "onboarding" >> /boot/oem
      mount -o remount,ro /boot
    fi
    res=$(grep luks_reencrypted /boot/oem > /dev/null 2>&1)
    if [ $? -ne 0 ];then
      export reownership_state="luks_reencryption"
      totp_confirm="R"
      echo $totp_confirm > /tmp/whiptail
      return
    fi
    res=$(grep luks_passwd_changed /boot/oem > /dev/null 2>&1)
    if [ $? -ne 0 ];then
      export reownership_state="luks_password_change"
      totp_confirm="R"
      return
    fi
    res=$(grep gpg_factory_resetted /boot/oem > /dev/null 2>&1)
    if [ $? -ne 0 ];then
      /bin/factory-reset-nitrokey-libremkey.sh
      return
    fi
    res=$(grep tpm_reowned /boot/oem > /dev/null 2>&1)
    if [ $? -ne 0 ];then
      totp_confirm="p"
      echo $totp_confirm > /tmp/whiptail
      return
    fi
    if [ $(grep -E "luks_reencrypted|luks_passwd_changed|gpg_factory_resetted|tpm_reowned" /boot/oem | uniq | wc -l) -eq 4 ];then
      if [ $HOTP = "Success" ];then
        mount -o remount,rw /boot
        rm /boot/oem
        mount -o remount,ro /boot
        unset totp_confirm
        unset reownership_state
        if [ "$CONFIG_OFFER_TPM_LUKS_DISK_UNLOCK_KEY" = "y" ]; then
          whiptail --title 'DISK UNLOCK KEY ADVICE 1/3' --msgbox \
            "***You SHOULD SET a new Disk Unlock Key for your own data privacy!!!***\n\nDoing so, a witness will only be able to type observed Disk Unlock\n Key passphrase from this computer and won't be able on a cloned\n copy of this disk.\n\nThe release of Disk Unlock Key happens ONLY if TPM attests firmware\nintegrity, and only if Disk Unlock Key passphrase is valid.\n\nPlease hit Enter to continue" 30 60

          whiptail --title 'DISK UNLOCK KEY ADVICE 2/3' --msgbox \
            "Otherwise, typing your Disk Recovery Key passphrase at boot puts you\nat risk. Someone could clone your disk and type that witnessed\npassphrase and access your data both locally and from a cloned\ndisk.\n\nCoupled with a strong passphrase, this improves your data privacy.\nCONSIDER YOURSELF WARNED.\n\nPlease hit Enter to continue" 30 60

          whiptail --title 'DISK UNLOCK KEY ADVICE 3/3' --msgbox \
            "To set Disk Unlock Key, released by the TPM only if firmware integrity\n is attested:\n\nSelect from Main menu:\n\nAdvanced Options menu -> Other Boot Options -> Show OS boot menu\n1-Then select the first boot option proposed (dynamic option)\n2-Then,answer Y when asked to add Disk Unlock Key to the TPM.\n\nYou will be prompted to set one in the following steps.\n\nPlease hit Enter to continue" 30 60
        fi
        return 
      else
        #Deal with corner case where after inserting key in previous step, HOTP seal fails with provided good password.
        #In that case, we regenerate HOTP and TOTP
        totp_confirm="g"
        echo $totp_confirm > /tmp/whiptail
      fi
    fi
  else
    reset_disk_unlock_key
    return
  fi  
}

reset_disk_unlock_key()
{
  mount_boot
  
  if [ "$CONFIG_TPM" = n ]; then
    TOTP="NO TPM"
  else
    TOTP=`unseal-totp`
    if [ $? -ne 0 ]; then
      echo "Error generating TOTP code. We will regenerate it now."
      update_totp
      continue
    elif [ -x /bin/libremkey_hotp_verification ]; then
      HOTP=`unseal-hotp`
      enable_usb
      if ! libremkey_hotp_verification info ; then
        whiptail $CONFIG_WARNING_BG_COLOR --clear --title 'WARNING: Please Insert Your Librem Key/Nitrokey' --msgbox "Your Librem Key/Nitrokey was not detected.\n\nPlease insert your Librem Key/Nitrokey" 30 90
      fi
      # Don't output HOTP codes to screen, so as to make replay attacks harder
      libremkey_hotp_verification check "$HOTP"
      case "$?" in
        0 )
          HOTP="Success"
        ;;
        4 )
          HOTP="Invalid code"
          MAIN_MENU_BG_COLOR=$CONFIG_ERROR_BG_COLOR
        ;;
        * )
          HOTP="Error checking code, Insert Librem Key/Nitrokey and retry"
          MAIN_MENU_BG_COLOR=$CONFIG_WARNING_BG_COLOR
        ;;
      esac
    else
      HOTP='N/A'
    fi
      
    if [ $HOTP = "Success" ];then
      mount -o remount,rw /boot
      rm -f /boot/reset_disk_unlock_key
      mount -o remount,ro /boot
      verify_global_hashes
      kexec-select-boot -m -b /boot -c "grub.cfg" -g
      continue
    else
      echo -e "HOTP status: $HOTP\n\nHit Enter to regenerate new TOTP/HOTP codes."
      read
      update_totp
    fi
    continue
  fi
}
