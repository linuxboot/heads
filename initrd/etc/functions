#!/bin/sh
# Shell functions for most initialization scripts

die() {
	echo >&2 "$*";
	read -p 'Hit enter to continue.'
	exit 1;
}

debug(){
  echo >&2 "$*";
  read -p 'Hit enter to continue.'
}

error() {
	echo >&2 "$*";
  exit 1;
}

warn() {
	echo >&2 "$*";
}

recovery() {
	echo >&2 "!!!!! $*"

	# Remove any temporary secret files that might be hanging around
	# but recreate the directory so that new tools can use it.
	shred -n 10 -z -u /tmp/secret/* 2> /dev/null
	rm -rf /tmp/secret
	mkdir -p /tmp/secret

	# ensure /tmp/config exists for recovery scripts that depend on it
	touch /tmp/config

	if [ "$CONFIG_TPM" = y ]; then
		tpm extend -ix 4 -ic recovery
	fi
	echo >&2 "!!!!! Starting recovery shell"
	sleep 1

	if [ -x /bin/setsid ]; then
		exec /bin/setsid -c /bin/ash
	else
		exec /bin/ash
	fi
}

pause_recovery() {
	read -p 'Hit enter to proceed to recovery shell:'
	recovery $*
}

pcrs() {
	head -8 /sys/class/tpm/tpm0/pcrs
}

confirm_totp()
{
	prompt="$1"
	last_half=X
	unset totp_confirm

	while true; do

		# update the TOTP code every thirty seconds
		date=`date "+%Y-%m-%d %H:%M:%S"`
		seconds=`date "+%s"`
		half=`expr \( $seconds % 60 \) / 30`
		if [ "$CONFIG_TPM" != y ]; then
			TOTP="NO TPM"
		elif [ "$half" != "$last_half" ]; then
			last_half=$half;
			TOTP=`unseal-totp` \
			|| recovery "TOTP code generation failed"
		fi

		echo -n "$date $TOTP: "

		# read the first character, non-blocking
		read \
			-t 1 \
			-n 1 \
			-s \
			-p "$prompt" \
			totp_confirm \
		&& break

		# nothing typed, redraw the line
		echo -ne '\r'
	done

	# clean up with a newline
	echo
}

enable_usb()
{
	if [ "$CONFIG_LINUX_USB_COMPANION_CONTROLLER" = y ]; then
		if ! lsmod | grep -q uhci_hcd; then
			insmod /lib/modules/uhci-hcd.ko \
			|| die "uhci_hcd: module load failed"
		fi
		if ! lsmod | grep -q ohci_hcd; then
			insmod /lib/modules/ohci-hcd.ko \
			|| die "ohci_hcd: module load failed"
		fi
		if ! lsmod | grep -q ohci_pci; then
			insmod /lib/modules/ohci-pci.ko \
			|| die "ohci_pci: module load failed"
		fi
	fi
	if ! lsmod | grep -q ehci_hcd; then
		insmod /lib/modules/ehci-hcd.ko \
		|| die "ehci_hcd: module load failed"
	fi
	if ! lsmod | grep -q ehci_pci; then
		insmod /lib/modules/ehci-pci.ko \
		|| die "ehci_pci: module load failed"
	fi
	if ! lsmod | grep -q xhci_hcd; then
		insmod /lib/modules/xhci-hcd.ko \
		|| die "xhci_hcd: module load failed"
	fi
	if ! lsmod | grep -q xhci_pci; then
		insmod /lib/modules/xhci-pci.ko \
		|| die "xhci_pci: module load failed"
		sleep 2
	fi
}

file_selector() {
  FILE=""
  FILE_LIST=$1
  MENU_MSG=${2:-"Choose the file"}
  # create file menu options
  if [ $(cat "$FILE_LIST" | wc -l) -gt 0 ]; then
    option=""
    while [ -z "$option" ]
    do
      MENU_OPTIONS=""
      n=0
      while read option
      do
        n=$(expr $n + 1)
        option=$(echo "$option" | tr " " "_")
        MENU_OPTIONS="$MENU_OPTIONS $n ${option}"
      done < $FILE_LIST

      MENU_OPTIONS="$MENU_OPTIONS a Abort"
      whiptail --clear --title "Select your File" \
        --menu "${MENU_MSG} [1-$n, a to abort]:" 20 120 8 \
        -- $MENU_OPTIONS \
        2>/tmp/whiptail || die "Aborting"

      option_index=$(cat /tmp/whiptail)

      if [ "$option_index" = "a" ]; then
        option="a"
        return
      fi

      option=$(head -n "$option_index" "$FILE_LIST" | tail -1)
      if [ "$option" == "a" ]; then
        return
      fi
    done
    if [ -n "$option" ]; then
      FILE=$option
    fi
  else
    whiptail $CONFIG_ERROR_BG_COLOR --title 'ERROR: No Files Found' \
      --msgbox "No Files found matching the pattern. Aborting." 16 60
    exit 1
  fi
}

mount_boot()
{
  # Mount local disk if it is not already mounted
  if ! grep -q /boot /proc/mounts ; then
    mount -o ro /boot \
      || recovery "Unable to mount /boot from $CONFIG_BOOT_DEV"
  fi
}

confirm_gpg_card()
{
	read \
		-n 1 \
		-p "Please confirm that your GPG card is inserted [Y/n]: " \
		card_confirm
	echo

	if [ "$card_confirm" != "y" \
		-a "$card_confirm" != "Y" \
		-a -n "$card_confirm" ] \
	; then
		die "gpg card not confirmed"
	fi

	# setup the USB so we can reach the GPG card
	enable_usb

	gpg --card-status \
	|| die "gpg card read failed"
}

check_tpm_counter()
{
  LABEL=${2:-3135106223}
	# if the /boot.hashes file already exists, read the TPM counter ID
	# from it.
	if [ -r "$1" ]; then
		TPM_COUNTER=`grep counter- "$1" | cut -d- -f2`
  else 
    warn "$1 does not exist; creating new TPM counter"
    if [ -z "$oem_TPM_Owner_Password" ]; then
		  read -s -p "TPM Owner password: " tpm_password
		  echo
    else
      tpm_password=$(echo -n "$oem_TPM_Owner_Password")
    fi

		tpm counter_create \
			-pwdo "$tpm_password" \
			-pwdc '' \
			-la $LABEL \
		| tee /tmp/counter \
		|| die "Unable to create TPM counter"
		TPM_COUNTER=`cut -d: -f1 < /tmp/counter`
	fi

	if [ -z "$TPM_COUNTER" ]; then
		die "$1: TPM Counter not found?"
	fi
}

read_tpm_counter()
{
	tpm counter_read -ix "$1" | tee "/tmp/counter-$1" \
	|| die "Counter read failed"
}

increment_tpm_counter()
{
	tpm counter_increment -ix "$1" -pwdc '' \
		| tee /tmp/counter-$1 \
	|| die "Counter increment failed"
}

check_config() {
	if [ ! -d /tmp/kexec ]; then
		mkdir /tmp/kexec \
		|| die 'Failed to make kexec tmp dir'
	else
		rm -rf /tmp/kexec/* \
		|| die 'Failed to empty kexec tmp dir'
	fi

	if [ ! -r $1/kexec.sig ]; then
		return
	fi

	if [ `find $1/kexec*.txt | wc -l` -eq 0 ]; then
		return
	fi

	if [ "$2" != "force" ]; then
		if ! sha256sum `find $1/kexec*.txt` | gpgv $1/kexec.sig - ; then
			die 'Invalid signature on kexec boot params. Investigate/Update checksums and sign all files in /boot.'
      #TODO: Show which files failed integrity check!
		fi
	fi

	echo "+++ Found verified kexec boot params"
	cp $1/kexec*.txt /tmp/kexec \
	|| die "Failed to copy kexec boot params to tmp"
}

preserve_rom() {
	new_rom="$1"
	old_files=`cbfs -t 50 -l 2>/dev/null | grep "^heads/"`

	for old_file in `echo $old_files`; do
		new_file=`cbfs -o $1 -l | grep -x $old_file`
		if [ -z "$new_file" ]; then
			echo "+++ Adding $old_file to $1"
			cbfs -t 50 -r $old_file >/tmp/rom.$$ \
			|| die "Failed to read cbfs file from ROM"
			cbfs -o $1 -a $old_file -f /tmp/rom.$$ \
			|| die "Failed to write cbfs file to new ROM file"
		fi
	done
}
replace_config() {
	CONFIG_FILE=$1
	CONFIG_OPTION=$2
	NEW_SETTING=$3

	touch $CONFIG_FILE
# first pull out the existing option from the global config and place in a tmp file
	awk "gsub(\"^export ${CONFIG_OPTION}=.*\",\"export ${CONFIG_OPTION}=\\\"${NEW_SETTING}\\\"\")" /tmp/config > ${CONFIG_FILE}.tmp
	awk "gsub(\"^${CONFIG_OPTION}=.*\",\"${CONFIG_OPTION}=\\\"${NEW_SETTING}\\\"\")" /tmp/config >> ${CONFIG_FILE}.tmp

# then copy any remaining settings from the existing config file, minus the option you changed
	grep -v "^export ${CONFIG_OPTION}=" ${CONFIG_FILE} | grep -v "^${CONFIG_OPTION}=" >> ${CONFIG_FILE}.tmp || true
  sort ${CONFIG_FILE}.tmp | uniq > ${CONFIG_FILE}
	rm -f ${CONFIG_FILE}.tmp
}
combine_configs() {
	cat /etc/config* > /tmp/config
}
read_oem_file()
{
  echo "Mounting USB drive to provision OEM reownership from /media/oem-provisioning..."
  /bin/mount-usb rw || warn "Unable to mount USB device. Continuing"
  if [ -e /media/oem-provisioning ]; then
    oem_gpg_Admin_PIN=$(grep "^oem_gpg_Admin_PIN=" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_gpg_Admin_PIN" ] && [ $(echo "$oem_gpg_Admin_PIN" | wc -l ) -eq 1 ]; then
      export oem_gpg_Admin_PIN="$oem_gpg_Admin_PIN"
    else
      warn "Multiple 'oem_gpg_Admin_PIN=' statements found. None retained."
      unset oem_gpg_Admin_PIN
      error=1
    fi
  
    oem_gpg_User_PIN=$(grep "^oem_gpg_User_PIN=" /media/oem-provisioning | cut -d "=" -f2) 
    if [ -n "$oem_gpg_User_PIN" ] && [ $(echo "$oem_gpg_User_PIN" | wc -l ) -eq 1 ]; then
      export oem_gpg_User_PIN="$oem_gpg_User_PIN"
    else
      warn "Multiple 'oem_gpg_User_PIN=' statements found. None retained."
      unset oem_gpg_User_PIN
      error=1
    fi

    oem_gpg_real_name=$(grep "^oem_gpg_real_name=" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_gpg_real_name" ] && [ $(echo "$oem_gpg_real_name" | wc -l ) -eq 1 ]; then
      export oem_gpg_real_name="$oem_gpg_real_name"
    else
      warn "Multiple 'oem_gpg_real_name=' statements found. None retained."
      unset oem_gpg_real_name
      error=1
    fi

    oem_gpg_email=$(grep "^oem_gpg_email=" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_gpg_email" ] && [ $(echo "$oem_gpg_email" | wc -l ) -eq 1 ]; then
      export oem_gpg_email="$oem_gpg_email"
    else
      warn "Multiple 'oem_gpg_email=' statements found. None retained."
      unset oem_gpg_email
      error=1 
    fi

    oem_gpg_comment=$(grep "^oem_gpg_comment=" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_gpg_comment" ] && [ $(echo "$oem_gpg_comment" | wc -l ) -eq 1 ]; then
      export oem_gpg_comment="$oem_gpg_comment"
    else
      warn "Multiple 'oem_gpg_comment=' statements found. None retained."
      unset oem_gpg_comment
      error=1
    fi

    oem_luks_actual_Disk_Recovery_Key=$(grep "^oem_luks_actual_Disk_Recovery_Key=" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_luks_actual_Disk_Recovery_Key" ] && [ $(echo "$oem_luks_actual_Disk_Recovery_Key" | wc -l ) -eq 1 ]; then
      export oem_luks_actual_Disk_Recovery_Key="$oem_luks_actual_Disk_Recovery_Key"
    else
      warn "Multiple 'oem_luks_actual_Disk_Recovery_Key=' statements found. None retained."
      unset oem_luks_actual_Disk_Recovery_Key
      error=1
    fi

    oem_luks_new_Disk_Recovery_Key=$(grep "^oem_luks_new_Disk_Recovery_Key=" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_luks_new_Disk_Recovery_Key" ] && [ $(echo "$oem_luks_new_Disk_Recovery_Key" | wc -l ) -eq 1 ]; then
      export oem_luks_new_Disk_Recovery_Key="$oem_luks_new_Disk_Recovery_Key"
    else
      warn "Multiple 'oem_luks_new_Disk_Recovery_Key=' statements found. None retained."
      unset oem_luks_new_Disk_Recovery_Key
      error=1
    fi

    oem_luks_Disk_Unlock_Key=$(grep "^oem_luks_Disk_Unlock_Key=" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_luks_Disk_Unlock_Key" ] && [ $(echo "$oem_luks_Disk_Unlock_Key" | wc -l ) -eq 1 ]; then
      export oem_luks_Disk_Unlock_Key="$oem_luks_Disk_Unlock_Key"
    else
      warn "Multiple 'oem_luks_Disk_Unlock_Key=' statements found. None retained."
      unset oem_luks_Disk_Unlock_Key
      error=1
    fi

    oem_TPM_Owner_Password=$(grep "^oem_TPM_Owner_Password=" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_TPM_Owner_Password" ] && [ $(echo "$oem_TPM_Owner_Password" | wc -l ) -eq 1 ]; then
      export oem_TPM_Owner_Password="$oem_TPM_Owner_Password"
    else
      warn "Multiple 'oem_TPM_Owner_Password=' statements found. None retained."
      unset oem_TPM_Owner_Password
      error=1
    fi
    
    if [ -n $error ] && [ "$error" -eq 1 ]; then
      recovery "Please run 'vi /media/oem-provisioning' to correct previous warnings. ('i': insert, modify, 'Esc' key, then ':wq', 'Enter' key, then 'unmount /media' and 'reboot'."
    fi

    export oem_configuration_read=1
    umount /media
  fi
}

check_onboarding_progress()
{
  mount_boot
  if [ -e /boot/oem ]; then
    res=$(grep onboarding /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      #Show Onboarding menu once.
      whiptail --title 'Hardware reownership Wizard' --msgbox \
       "The received hardware is currently owned by $oem_name.\nWe will change that.\n\nThis Wizard will otherwise make you own your own hardware by:\n1-Reencrypting encrypted drive content (LUKS container)\n2-Changing LUKS Disk Recovery Key and it's passphrase\n3-Resetting your Librem Key/Nitrokey Pro v2 to factory defaults\n4-Setting User and Admin PINs into your Librem Key/NitroKey\n5-Generating keys in it, exporting public key and\n importing it in the ROM prior to reprogramming the SPI flash with it\n6-Taking integrity measures of all /boot files and sign the resulting\n checksum file with your Librem Key/Nitrokey Pro\n7-Reowning your Trusted Platform Module (TPM)\n\nScan the QR Code with an OTP app only after Reset the TPM last phase.\n\nHit Enter to continue." 20 20
      whiptail --title 'Hardware reownership Wizard' --msgbox \
       "On the next screen, MAKE SURE THAT THE HOTP CODE IS: 'Success'\n\nIf it's not, reboot your hardware with your Librem/Nitrokey inserted.\n\nIf the HOTP code is still invalid, your hardware may been tampered with in\ntransit. Contact $oem_name." 20 20
      totp_confirm="O"
      echo $totp_confirm > /tmp/whiptail
      mount -o remount,rw /boot
      echo "onboarding" >> /boot/oem
      mount -o remount,ro /boot
    fi
    res=$(grep luks_reencrypted /boot/oem > /dev/null 2>&1)
    if [ $? -ne 0 ];then
      export reownership_state="luks_reencryption"
      totp_confirm="R"
      echo $totp_confirm > /tmp/whiptail
      return
    fi
    res=$(grep luks_passwd_changed /boot/oem > /dev/null 2>&1)
    if [ $? -ne 0 ];then
      export reownership_state="luks_password_change"
      totp_confirm="R"
      return
    fi
    res=$(grep gpg_factory_resetted /boot/oem > /dev/null 2>&1)
    if [ $? -ne 0 ];then
      /bin/factory-reset-nitrokey-libremkey.sh
      return
    fi
    res=$(grep tpm_reowned /boot/oem > /dev/null 2>&1)
    if [ $? -ne 0 ];then
      totp_confirm="p"
      echo $totp_confirm > /tmp/whiptail
      return
    fi
    if [ $(grep -E "luks_reencrypted|luks_passwd_changed|gpg_factory_resetted|tpm_reowned" /boot/oem | uniq | wc -l) -eq 4 ];then
      if [ $HOTP = "Success" ];then
        mount -o remount,rw /boot
        rm /boot/oem
        mount -o remount,ro /boot
        unset totp_confirm
        unset reownership_state
        if [ "$CONFIG_OFFER_TPM_LUKS_DISK_UNLOCK_KEY" = "y" ]; then
          whiptail --title 'DISK UNLOCK KEY ADVICE 1/3' --msgbox \
            "***You SHOULD SET a new Disk Unlock Key for your own data privacy!!!***\n\nDoing so, a witness will only be able to type observed Disk Unlock\n Key passphrase from this computer and won't be able on a cloned\n copy of this disk.\n\nThe release of Disk Unlock Key happens ONLY if TPM attests firmware\nintegrity, and only if Disk Unlock Key passphrase is valid.\n\nPlease hit Enter to continue" 30 60

          whiptail --title 'DISK UNLOCK KEY ADVICE 2/3' --msgbox \
            "Otherwise, typing your Disk Recovery Key passphrase at boot puts you\nat risk. Someone could clone your disk and type that witnessed\npassphrase and access your data both locally and from a cloned\ndisk.\n\nCoupled with a strong passphrase, this improves your data privacy.\nCONSIDER YOURSELF WARNED.\n\nPlease hit Enter to continue" 30 60

          whiptail --title 'DISK UNLOCK KEY ADVICE 3/3' --msgbox \
            "To set Disk Unlock Key, released by the TPM only if firmware integrity\n is attested:\n\nSelect from Main menu:\n\nAdvanced Options menu -> Other Boot Options -> Show OS boot menu\n1-Then select the first boot option proposed (dynamic option)\n2-Then,answer Y when asked to add Disk Unlock Key to the TPM.\n\nYou will be prompted to set one in the following steps.\n\nPlease hit Enter to continue" 30 60
        fi
        return 
      else
        #Deal with corner case where after inserting key in previous step, HOTP seal fails with provided good password.
        #In that case, we regenerate HOTP and TOTP
        totp_confirm="g"
        echo $totp_confirm > /tmp/whiptail
      fi
    fi
  else
    reset_disk_unlock_key
    return
  fi  
}

reset_disk_unlock_key()
{
  mount_boot
  
  if [ "$CONFIG_TPM" = n ]; then
    TOTP="NO TPM"
  else
    TOTP=`unseal-totp`
    if [ $? -ne 0 ]; then
      echo "Error generating TOTP code. We will regenerate it now."
      update_totp
      continue
    elif [ -x /bin/libremkey_hotp_verification ]; then
      HOTP=`unseal-hotp`
      enable_usb
      if ! libremkey_hotp_verification info ; then
        whiptail $CONFIG_WARNING_BG_COLOR --clear --title 'WARNING: Please Insert Your Librem Key/Nitrokey' --msgbox "Your Librem Key/Nitrokey was not detected.\n\nPlease insert your Librem Key/Nitrokey" 30 90
      fi
      # Don't output HOTP codes to screen, so as to make replay attacks harder
      libremkey_hotp_verification check "$HOTP"
      case "$?" in
        0 )
          HOTP="Success"
        ;;
        4 )
          HOTP="Invalid code"
          MAIN_MENU_BG_COLOR=$CONFIG_ERROR_BG_COLOR
        ;;
        * )
          HOTP="Error checking code, Insert Librem Key/Nitrokey and retry"
          MAIN_MENU_BG_COLOR=$CONFIG_WARNING_BG_COLOR
        ;;
      esac
    else
      HOTP='N/A'
    fi
      
    if [ $HOTP = "Success" ];then
      mount -o remount,rw /boot
      rm -f /boot/reset_disk_unlock_key
      mount -o remount,ro /boot
      verify_global_hashes
      kexec-select-boot -m -b /boot -c "grub.cfg" -g
      continue
    else
      echo -e "HOTP status: $HOTP\n\nHit Enter to regenerate new TOTP/HOTP codes."
      read
      update_totp
    fi
    continue
  fi
}
