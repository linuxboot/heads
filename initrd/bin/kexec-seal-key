#!/bin/bash
# This will generate a disk encryption key and seal / encrypt
# with the current PCRs and then store it in the TPM NVRAM.
# It will then need to be bundled into initrd that is booted.
set -e -o pipefail
. /etc/functions

find_drk_key_slot() {
    local temp_drk_key_slot=""
    local keyslot

    for keyslot in "${luks_used_keyslots[@]}"; do
        if [ -z "$temp_drk_key_slot" ]; then
            if DO_WITH_DEBUG cryptsetup open --test-passphrase --key-slot "$keyslot" --key-file "$DISK_RECOVERY_KEY_FILE" "$dev"; then
                temp_drk_key_slot="$keyslot"
                DEBUG "DRK slot is $temp_drk_key_slot and key slot is $keyslot"
                break
            fi
        fi
    done

    echo "$temp_drk_key_slot"
}

TPM_INDEX=3
TPM_SIZE=312
DUK_KEY_FILE="/tmp/secret/secret.key"
TPM_SEALED="/tmp/secret/secret.sealed"
DISK_RECOVERY_KEY_FILE="/tmp/secret/recovery.key"

. /etc/functions
. /tmp/config

TRACE_FUNC

paramsdir=$1
if [ -z "$paramsdir" ]; then
	die "Usage $0 /boot"
fi

KEY_DEVICES="$paramsdir/kexec_key_devices.txt"
KEY_LVM="$paramsdir/kexec_key_lvm.txt"

if [ ! -r "$KEY_DEVICES" ]; then
	die "No devices defined for disk encryption"
else
	DEBUG "Devices defined for disk encryption: $(cat "$KEY_DEVICES" | cut -d\  -f1 | tr '\n' ' ')"
fi

if [ -r "$KEY_LVM" ]; then
	# Activate the LVM volume group
	VOLUME_GROUP=$(cat $KEY_LVM)
	if [ -z "$VOLUME_GROUP" ]; then
		die "No LVM volume group defined for activation"
	fi
	lvm vgchange -a y $VOLUME_GROUP ||
		die "$VOLUME_GROUP: unable to activate volume group"
else
	DEBUG "No LVM volume group defined for activation"
fi

DEBUG "$(pcrs)"

for dev in $(cat "$KEY_DEVICES" | cut -d\  -f1); do
	attempts=0
	while [ $attempts -lt 3 ]; do
		read -s -p "Enter LUKS Disk Recovery Key/passphrase for $dev: " disk_password
		echo -n "$disk_password" >"$DISK_RECOVERY_KEY_FILE"
		echo

		DEBUG "Testing $DISK_RECOVERY_KEY_FILE keyfile created from provided passphrase against $dev"
		if cryptsetup open $dev --test-passphrase --key-file "$DISK_RECOVERY_KEY_FILE" >/dev/null 2>&1; then
			DEBUG "LUKS device $dev unlocked successfully with the provided passphrase"
			break
		else
			attempts=$((attempts + 1))
			if [ $attempts -eq 3 ]; then
				die "Failed to unlock LUKS device $dev with the provided passphrase. Exiting..."
			else
				echo "Incorrect passphrase. Please try again."
			fi
		fi
	done
done

attempts=0
while [ $attempts -lt 3 ]; do
	read -s -p "New LUKS TPM Disk Unlock Key passphrase for booting: " key_password
	echo
	read -s -p "Repeat LUKS TPM Disk Unlock Key passphrase for booting: " key_password2
	echo
	if [ "$key_password" != "$key_password2" ]; then
		attempts=$((attempts + 1))
		if [ $attempts -eq 3 ]; then
			die "Key passphrases do not match. Exiting..."
		else
			echo "Key passphrases do not match. Please try again."
		fi
	else
		break
	fi
done

# Generate key file
echo "++++++ Generating new randomized 128 bytes key file that will be sealed/unsealed by LUKS TPM Disk Unlock Key passphrase"
dd \
	if=/dev/urandom \
	of="$DUK_KEY_FILE" \
	bs=1 \
	count=128 \
	2>/dev/null ||
	die "Unable to generate 128 random bytes"

previous_luks_header_version=0
for dev in $(cat "$KEY_DEVICES" | cut -d\  -f1); do
	# Test the recovery key against the device before going any further
	DEBUG "Testing $DISK_RECOVERY_KEY_FILE keyfile created from provided passphrase against $dev"
	if ! cryptsetup open $dev --test-passphrase --key-file "$DISK_RECOVERY_KEY_FILE"; then
		rm "$DISK_RECOVERY_KEY_FILE"
		die "$dev: Unable to unlock LUKS device $dev with the provided passphrase. Exiting..."
	fi
	DEBUG "LUKS device $dev unlocked successfully with the provided passphrase"
	# Check and store LUKS version of the devices to be used later
	luks_version=$(cryptsetup luksDump "$dev" | grep "Version" | cut -d: -f2 | tr -d '[:space:]')
	if [ "$luks_version" == "2" ] && [ "$previous_luks_header_version" == "1" ]; then
		die "$dev: LUKSv2 device detected but LUKSv1 device was detected previously. Exiting..."
	fi

	if [ $luks_version -eq 1 ] && [ $previous_luks_header_version -eq 2 ]; then
		die "$dev: LUKSv1 device detected but LUKSv2 device was detected previously. Exiting..."
	fi

	if [ "$luks_version" == "2" ]; then
		#keyslot is the last slot for LUKSv2 which is 31
		duk_keyslot=31
		regex="([0-9]+): luks2"
		sed_command="s/\([0-9]+\): luks2/\1/"
		previous_luks_header_version=2
		DEBUG "LUKSv2 device detected for $dev"
	elif [ "$luks_version" == "1" ]; then
		#keyslot is the last slot for LUKSv1 which is 7
		duk_keyslot=7
		regex="Key Slot ([0-9]+): ENABLED"
		sed_command='s/Key Slot ([0-9]+): ENABLED/\1/'
		previous_luks_header_version=1
		DEBUG "LUKSv1 device detected for $dev"
	else
		die "$dev: Unsupported LUKS version $luks_version"
	fi

	# drk_key_slot will be the slot number where the passphrase was tested against as valid. We will keep that slot
	drk_key_slot="-1"

	TRACE_FUNC
	luks_used_keyslots=( $(cryptsetup luksDump "$dev" | grep -E "$regex" | sed -r "$sed_command") )
	DEBUG "LUKS key slots for $dev: ${luks_used_keyslots[*]}"
	TRACE_FUNC

	# Assign the temporary variable to drk_key_slot after the loop
	drk_key_slot=$(find_drk_key_slot)

	#if we didn't find the DRK key slot, we can't continue (we should not arrive here)
	if [ "$drk_key_slot" == "-1" ]; then
		die "$dev: Unable to find the key slot where the passphrase was tested against as valid. Exiting..."
	fi

	# if we found the DRK key slot, we wipe all the other slots on current $dev
	for keyslot in "${luks_used_keyslots[@]}"; do
		if [ "$keyslot" != "$drk_key_slot" ]; then
			#set wipe_desired to no by default
			wipe_desired="no"

			if [ "$keyslot" != "$drk_key_slot" ] && [ "$keyslot" == "1" ]; then
				# If keyslot is 1 (earlier DUK fixated behavior) or LUKsv1:7/LUKSv2:31
				#  we wipe it without asking since not DRK's good keyslot.
				wipe_desired="yes"
				DEBUG "LUKS keyslot $keyslot not DRK. Will wipe this DUK keyslot silently"
			elif [ "$keyslot" != "$drk_key_slot" ] && [ "$keyslot" != "$duk_keyslot" ]; then
				# Heads expects key-slot LUKSv1:7 or LUKSv2:31 to be used for TPM DUK setup.
				#Ask user to confirm with big fat warning otherwise
				read -p "WARNING: LUKS key-slot $keyslot is not typical ($duk_keyslot expected) for TPM Disk Unlock Key setup. Are you sure you want to wipe it? [y/N] " -n 1 -r
				echo
				# If user does not confirm, skip this slot
				if [[ $REPLY =~ ^[Yy]$ ]]; then
					wipe_desired="yes"
				fi
			elif [ "$keyslot" == "$duk_keyslot" ]; then
				# If keyslot is the expected DUK keyslot, we wipe it silently
				DEBUG "LUKS keyslot $keyslot is the expected DUK keyslot. Will wipe this DUK keyslot silently"
				wipe_desired="yes"
			fi

			if [ "$wipe_desired" == "yes" ]; then
				echo "++++++ $dev: Wiping LUKS key-slot $keyslot"
				DO_WITH_DEBUG cryptsetup luksKillSlot \
					--key-file "$DISK_RECOVERY_KEY_FILE" \
					$dev $keyslot ||
					warn "$dev: removal of LUKS slot $keyslot failed: Continuing"
			fi
		fi
	done

	# We then add the new key to the luks key slot LUKSv1:7 or LUKSv2:31
	for dev in $(cat "$KEY_DEVICES" | cut -d\  -f1); do
		echo "++++++ $dev: Adding LUKS TPM Disk Unlock Key to LUKS key-slot $duk_keyslot"
		DO_WITH_DEBUG cryptsetup luksAddKey \
			--key-file "$DISK_RECOVERY_KEY_FILE" \
			--new-key-slot $duk_keyslot \
			$dev "$DUK_KEY_FILE" ||
			die "$dev: Unable to add LUKS TPM Disk Unlock Key to LUKS key-slot $duk_keyslot"
	done
done

# Now that we have setup the new keys, measure the PCRs
# We don't care what ends up in PCR 6; we just want
# to get the /tmp/luksDump.txt file.  We use PCR16
# since it should still be zero
cat "$KEY_DEVICES" | cut -d\  -f1 | xargs /bin/qubes-measure-luks ||
	die "Unable to measure the LUKS headers"

pcrf="/tmp/secret/pcrf.bin"
tpmr pcrread 0 "$pcrf"
tpmr pcrread -a 1 "$pcrf"
tpmr pcrread -a 2 "$pcrf"
tpmr pcrread -a 3 "$pcrf"
# Note that PCR 4 needs to be set with the "normal-boot" path value, read it from event log.
tpmr calcfuturepcr 4 >>"$pcrf"
if [ "$CONFIG_USER_USB_KEYBOARD" = "y" -o -r /lib/modules/libata.ko -o -x /bin/hotp_verification ]; then
	DEBUG "Sealing LUKS TPM Disk Unlock Key with PCR5 involvement (additional kernel modules are loaded per board config)..."
	# Here, we take pcr 5 into consideration if modules are expected to be measured+loaded
	tpmr pcrread -a 5 "$pcrf"
else
	DEBUG "Sealing LUKS TPM Disk Unlock Key with PCR5=0 (NO additional kernel modules are loaded per board config)..."
	#no kernel modules are expected to be measured+loaded
	tpmr calcfuturepcr 5 >>"$pcrf"
fi
# Precompute the value for pcr 6
DEBUG "Precomputing TPM future value for PCR6 sealing/unsealing of LUKS TPM Disk Unlock Key..."
tpmr calcfuturepcr 6 "/tmp/luksDump.txt" >>"$pcrf"
# We take into consideration user files in cbfs
tpmr pcrread -a 7 "$pcrf"

DO_WITH_DEBUG --mask-position 7 \
	tpmr seal "$DUK_KEY_FILE" "$TPM_INDEX" 0,1,2,3,4,5,6,7 "$pcrf" \
	"$TPM_SIZE" "$key_password" || die "Unable to write LUKS TPM Disk Unlock Key to NVRAM"

# should be okay if this fails
shred -n 10 -z -u "$pcrf" 2>/dev/null ||
	warn "Failed to delete pcrf file - continuing"
shred -n 10 -z -u "$DUK_KEY_FILE" 2>/dev/null ||
	warn "Failed to delete key file - continuing"

mount -o rw,remount $paramsdir || warn "Failed to remount $paramsdir in RW - continuing"
cp -f /tmp/luksDump.txt "$paramsdir/kexec_lukshdr_hash.txt" ||
	warn "Failed to copy LUKS header hashes to /boot - continuing"
mount -o ro,remount $paramsdir || warn "Failed to remount $paramsdir in RO - continuing"
