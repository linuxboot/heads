#!/bin/sh
# Boot from a local disk installation

CONFIG_BOOT_GUI_MENU_NAME='Heads Boot Menu'

. /etc/functions
. /tmp/config

file_selector() {
  FILE=""
  FILE_LIST=$1
  MENU_MSG=${2:-"Choose the file"}
  # create file menu options
  if [ $(cat "$FILE_LIST" | wc -l) -gt 0 ]; then
    option=""
    while [ -z "$option" ]
    do
      MENU_OPTIONS=""
      n=0
      while read option
      do
        n=$(expr $n + 1)
        option=$(echo "$option" | tr " " "_")
        MENU_OPTIONS="$MENU_OPTIONS $n ${option}"
      done < $FILE_LIST

      MENU_OPTIONS="$MENU_OPTIONS a Abort"
      whiptail --clear --title "Select your File" \
        --menu "${MENU_MSG} [1-$n, a to abort]:" 20 120 8 \
        -- $MENU_OPTIONS \
        2>/tmp/whiptail || die "Aborting"

      option_index=$(cat /tmp/whiptail)

      if [ "$option_index" = "a" ]; then
        option="a"
        return
      fi

      option=$(head -n "$option_index" "$FILE_LIST" | tail -1)
      if [ "$option" == "a" ]; then
        return
      fi
    done
    if [ -n "$option" ]; then
      FILE=$option
    fi
  else
    whiptail $CONFIG_ERROR_BG_COLOR --title 'ERROR: No Files Found' \
      --msgbox "No Files found matching the pattern. Aborting." 16 60
    exit 1
  fi
}
verify_global_hashes()
{
  # Check the hashes of all the files, ignoring signatures for now
  check_config /boot force
  TMP_HASH_FILE="/tmp/kexec/kexec_hashes.txt"
  TMP_PACKAGE_TRIGGER_PRE="/tmp/kexec/kexec_package_trigger_pre.txt"
  TMP_PACKAGE_TRIGGER_POST="/tmp/kexec/kexec_package_trigger_post.txt"

  if cd /boot && sha256sum -c "$TMP_HASH_FILE" > /tmp/hash_output ; then
    return 0
  elif [ ! -f $TMP_HASH_FILE ]; then
    if (whiptail $CONFIG_ERROR_BG_COLOR --clear --title 'ERROR: Missing Hash File!' \
      --yesno "The file containing hashes for /boot is missing!\n\nIf you are setting this system up for the first time, select Yes to update\nyour list of checksums.\n\nOtherwise this could indicate a compromise and you should select No to\nreturn to the main menu.\n\nWould you like to update your checksums now?" 30 90) then
      update_checksums
    fi
    return 1
  else
    CHANGED_FILES=$(grep -v 'OK$' /tmp/hash_output | cut -f1 -d ':')

    # if files changed before package manager started, show stern warning
    if [ -f "$TMP_PACKAGE_TRIGGER_PRE" ]; then 
      PRE_CHANGED_FILES=$(grep '^CHANGED_FILES' $TMP_PACKAGE_TRIGGER_POST | cut -f 2 -d '=' | tr -d '"')
      TEXT="The following files failed the verification process BEFORE package updates ran:\n${PRE_CHANGED_FILES}\n\nCompare against the files Heads has detected have changed:\n${CHANGED_FILES}\n\nThis could indicate a compromise!\n\nWould you like to update your checksums anyway?"

    # if files changed after package manager started, probably caused by package manager
    elif [ -f "$TMP_PACKAGE_TRIGGER_POST" ]; then 
      LAST_PACKAGE_LIST=$(grep -E "^(Install|Remove|Upgrade|Reinstall):" $TMP_PACKAGE_TRIGGER_POST)
      UPDATE_INITRAMFS_PACKAGE=$(grep '^UPDATE_INITRAMFS_PACKAGE' $TMP_PACKAGE_TRIGGER_POST | cut -f 2 -d '=' | tr -d '"')

      if [ "$UPDATE_INITRAMFS_PACKAGE" != "" ]; then
        TEXT="The following files failed the verification process AFTER package updates ran:\n${CHANGED_FILES}\n\nThis is likely due to package triggers in$UPDATE_INITRAMFS_PACKAGE.\n\nYou will need to update your checksums for all files in /boot.\n\nWould you like to update your checksums now?"
      else
        TEXT="The following files failed the verification process AFTER package updates ran:\n${CHANGED_FILES}\n\nThis might be due to the following package updates:\n$LAST_PACKAGE_LIST.\n\nYou will need to update your checksums for all files in /boot.\n\nWould you like to update your checksums now?"
      fi

    else
      TEXT="The following files failed the verification process:\n${CHANGED_FILES}\n\nThis could indicate a compromise!\n\nWould you like to update your checksums now?"
    fi

    if (whiptail $CONFIG_ERROR_BG_COLOR --clear --title 'ERROR: Boot Hash Mismatch' --yesno "$TEXT" 30 90) then
      update_checksums
    fi
    return 1
  fi
}
update_checksums()
{
  if (whiptail --title 'Update Checksums and sign all files in /boot' \
      --yesno "You have chosen to update the checksums and sign all of the files in /boot.\n\nThis means that you trust that the files in /boot have not been tampered\n with.\n\nYou will need your GPG key to continue and this change will modify your\n disk.\n\nDo you want to continue?" 16 90) then
    mount_boot
    mount -o rw,remount /boot

    cd /boot || die "Not able to change directory to /boot."
    find ./ -type f ! -name '*kexec*' | xargs sha256sum > /boot/kexec_hashes.txt
    DEFAULT_FILES=$(cat /boot/kexec_default_hashes.txt | cut -f3 -d ' ')
    echo $DEFAULT_FILES | xargs sha256sum > /boot/kexec_default_hashes.txt

    # Remove any package trigger log files
    # We don't need them after the user decides to sign
    rm -f /boot/kexec_package_trigger*

    # sign and auto-roll config counter
    extparam=
    if [ "$CONFIG_TPM" = "y" ]; then
      extparam=-u
    fi
    kexec-sign-config -p /boot $extparam \
    || die "Failed to sign default config"

    # switch back to ro mode
    mount -o ro,remount /boot
  else
    echo "Returning to the main menu"
  fi
}
update_totp()
{
  echo "Scan the QR code to add the new TOTP secret"
  /bin/seal-totp $CONFIG_BOARD
  if [ -x /bin/libremkey_hotp_verification ]; then
    echo "Once you have scanned the QR code, hit Enter to configure your Librem Key/Nitrokey"
    read
    /bin/seal-libremkey
    while [ $? -ne 0 ];do
      echo -e "\n\nSealing HOTP secret into Librem Key/Nitrokey failed. Let's try again by resealing both TOTP and HOTP."
      update_totp
      /bin/seal-libremkey
    done
  else
    echo "Once you have scanned the QR code, hit Enter to reboot"
    read
  fi
  /bin/reboot
}
read_oem_file()
{
  echo "Mounting USB drive to provision OEM reownership from /media/oem-provisioning..."
  /bin/mount-usb || warn "Unable to mount USB device. Continuing"
  if [ -e /media/oem-provisioning ]; then
    oem_gpg_Admin_PIN=$(grep "oem_gpg_Admin_PIN" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_gpg_Admin_PIN" ]; then
      export oem_gpg_Admin_PIN="$oem_gpg_Admin_PIN"
    else
      unset oem_gpg_Admin_PIN
    fi
  
    oem_gpg_User_PIN=$(grep "oem_gpg_User_PIN" /media/oem-provisioning | cut -d "=" -f2) 
    if [ -n "$oem_gpg_User_PIN" ]; then
      export oem_gpg_User_PIN="$oem_gpg_User_PIN"
    else
      unset oem_gpg_User_PIN 
    fi

    oem_gpg_real_name=$(grep "oem_gpg_real_name" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_gpg_real_name" ]; then
      export oem_gpg_real_name="$oem_gpg_real_name"
    else
      unset oem_gpg_real_name
    fi

    oem_gpg_email=$(grep "oem_gpg_email" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_gpg_email" ]; then
      export oem_gpg_email="$oem_gpg_email"
    else
      unset oem_gpg_email 
    fi

    oem_gpg_comment=$(grep "oem_gpg_comment" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_gpg_comment" ]; then
      export oem_gpg_comment="$oem_gpg_comment"
    else
      unset oem_gpg_comment
    fi

    oem_luks_actual_Disk_Recovery_Key=$(grep "oem_luks_actual_Disk_Recovery_Key" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_luks_actual_Disk_Recovery_Key" ]; then
      export oem_luks_actual_Disk_Recovery_Key="$oem_luks_actual_Disk_Recovery_Key"
    else
      unset oem_luks_actual_Disk_Recovery_Key
    fi

    oem_luks_new_Disk_Recovery_Key=$(grep "oem_luks_new_Disk_Recovery_Key" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_luks_new_Disk_Recovery_Key" ]; then
      export oem_luks_new_Disk_Recovery_Key="$oem_luks_new_Disk_Recovery_Key"
    else
      unset oem_luks_new_Disk_Recovery_Key
    fi

    oem_luks_Disk_Unlock_Key=$(grep "oem_luks_Disk_Unlock_Key" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_luks_Disk_Unlock_Key" ]; then
      export oem_luks_Disk_Unlock_Key="$oem_luks_Disk_Unlock_Key"
    else
      unset oem_luks_Disk_Unlock_Key
    fi

    oem_TPM_Owner_Password=$(grep "oem_TPM_Owner_Password" /media/oem-provisioning | cut -d "=" -f2)
    if [ -n "$oem_TPM_Owner_Password" ]; then
      export oem_TPM_Owner_Password="$oem_TPM_Owner_Password"
    else
      unset oem_TPM_Owner_Password
    fi
  
    export oem_configuration_read=1
  fi
}
check_onboarding_progress()
{
  mount_boot
  if [ -e /boot/oem ]; then
    res=$(grep onboarding /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      #Show Onboarding menu once.
      whiptail --title 'Hardware reownership Wizard' --msgbox \
       "The received hardware is currently owned by $oem_name.\nWe will change that.\n\nThis Wizard will otherwise make you own your own hardware by:\n1-Reencrypting encrypted drive content (LUKS container)\n2-Changing LUKS Disk Recovery Key and it's passphrase\n3-Resetting your Librem Key/Nitrokey Pro v2 to factory defaults\n4-Setting User and Admin PINs into your Librem Key/NitroKey\n5-Generating keys in it, exporting public key and\n importing it in the ROM prior to reprogramming the SPI flash with it\n6-Taking integrity measures of all /boot files and sign the resulting\n checksum file with your Librem Key/Nitrokey Pro\n7-Reowning your Trusted Platform Module (TPM)\n\nScan the QR Code with an OTP app only after Reset the TPM last phase.\n\nHit Enter to continue." 20 20
      whiptail --title 'Hardware reownership Wizard' --msgbox \
       "On the next screen, MAKE SURE THAT THE HOTP CODE IS: 'Success'\n\nIf it's not, reboot your hardware with your Librem/Nitrokey inserted.\n\nIf the HOTP code is still invalid, your hardware may been tampered with in\ntransit. Contact $oem_name." 20 20
      totp_confirm="O"
      echo $totp_confirm > /tmp/whiptail
      mount -o remount,rw /boot
      echo "onboarding" >> /boot/oem
      mount -o remount,ro /boot
    fi
    res=$(grep luks_reencrypted /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      export reownership_state="luks_reencryption"
      totp_confirm="R"
      echo $totp_confirm > /tmp/whiptail
      return
    fi
    res=$(grep luks_passwd_changed /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      export reownership_state="luks_password_change"
      totp_confirm="R"
      return
    fi
    res=$(grep gpg_factory_resetted /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      /bin/factory-reset-nitrokey-libremkey.sh
      return
    fi
    res=$(grep tpm_reowned /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      totp_confirm="p"
      echo $totp_confirm > /tmp/whiptail
      return
    fi
    if [ $(grep -E "luks_reencrypted|luks_passwd_changed|gpg_factory_resetted|tpm_reowned" /boot/oem | uniq | wc -l) -eq 4 ];then
      if [ $HOTP = "Success" ];then
        mount -o remount,rw /boot
        rm /boot/oem
        mount -o remount,ro /boot
        unset totp_confirm
        unset reownership_state
        whiptail --title 'DISK UNLOCK KEY ADVICE 1/3' --msgbox \
          "***You SHOULD SET a new Disk Unlock Key for your own data privacy!!!***\n\nDoing so, a witness will only be able to type observed Disk Unlock\n Key passphrase from this computer and won't be able on a cloned\n copy of this disk.\n\nThe release of Disk Unlock Key happens ONLY if TPM attests firmware\nintegrity, and only if Disk Unlock Key passphrase is valid.\n\nPlease hit Enter to continue" 30 60

        whiptail --title 'DISK UNLOCK KEY ADVICE 2/3' --msgbox \
          "Otherwise, typing your Disk Recovery Key passphrase at boot puts you\nat risk. Someone could clone your disk and type that witnessed\npassphrase and access your data both locally and from a cloned\ndisk.\n\nCoupled with a strong passphrase, this improves your data privacy.\nCONSIDER YOURSELF WARNED.\n\nPlease hit Enter to continue" 30 60

        whiptail --title 'DISK UNLOCK KEY ADVICE 3/3' --msgbox \
          "To set Disk Unlock Key, released by the TPM only if firmware integrity\n is attested:\n\nSelect from Main menu:\n\nAdvanced Options menu -> Other Boot Options -> Show OS boot menu\n1-Then select the first boot option proposed (dynamic option)\n2-Then,answer Y when asked to add Disk Unlock Key to the TPM.\n\nYou will be prompted to set one in the following steps.\n\nPlease hit Enter to continue" 30 60
        return 
      else
        #Deal with corner case where after inserting key in previous step, HOTP seal fails with provided good password.
        #In that case, we regenerate HOTP and TOTP
        totp_confirm="g"
        echo $totp_confirm > /tmp/whiptail
      fi
    fi
  else
    reset_disk_unlock_key
    return
  fi  
}
reset_disk_unlock_key()
{
  mount_boot
  
  if [ "$CONFIG_TPM" = n ]; then
    TOTP="NO TPM"
  else
    TOTP=`unseal-totp`
    if [ $? -ne 0 ]; then
      echo "Error generating TOTP code. We will regenerate it now."
      update_totp
      continue
    elif [ -x /bin/libremkey_hotp_verification ]; then
      HOTP=`unseal-hotp`
      enable_usb
      if ! libremkey_hotp_verification info ; then
        whiptail $CONFIG_WARNING_BG_COLOR --clear --title 'WARNING: Please Insert Your Librem Key/Nitrokey' --msgbox "Your Librem Key/Nitrokey was not detected.\n\nPlease insert your Librem Key/Nitrokey" 30 90
      fi
      # Don't output HOTP codes to screen, so as to make replay attacks harder
      libremkey_hotp_verification check "$HOTP"
      case "$?" in
        0 )
          HOTP="Success"
        ;;
        4 )
          HOTP="Invalid code"
          MAIN_MENU_BG_COLOR=$CONFIG_ERROR_BG_COLOR
        ;;
        * )
          HOTP="Error checking code, Insert Librem Key/Nitrokey and retry"
          MAIN_MENU_BG_COLOR=$CONFIG_WARNING_BG_COLOR
        ;;
      esac
    else
      HOTP='N/A'
    fi
      
    if [ $HOTP = "Success" ];then
      mount -o remount,rw /boot
      rm /boot/reset_disk_unlock_key
      mount -o remount,ro /boot
      verify_global_hashes
      kexec-select-boot -m -b /boot -c "grub.cfg" -g
      continue
    else
      echo -e "HOTP status: $HOTP\n\nHit Enter to regenerate new TOTP/HOTP codes."
      read
      update_totp
    fi
    continue
  fi
}

mount_boot
if [ -e /boot/oem ];then
  if [ -z "$oem_configuration_read" ]; then
    #Read /media/oem-provisioning file once to read provisioned secrets
    read_oem_file
    
    oem_name=$(grep "oem_name" /boot/oem | awk -F '=' {'print $2'})
    if [ -n "$oem_name" ]; then
      export oem_name="$oem_name"
    else
      oem_name="your OEM"
      export oem_name="$oem_name"
    fi
  fi
fi


#TODO:validate that resetting disk unlock key only happens when /boot/oem doesn't exist anymore. Should happen after TPM reset.
#Flashing modifies measurements, which should trigger TOTP/HOTP resealing. That happens when inserting gpg public key.
#Measurements become invalid when TPM is reset, also.
if [ -e /boot/reset_disk_unlock_key ] && [ ! -e /boot/oem ]; then
  if (whiptail $CONFIG_WARNING_BG_COLOR --title "WARNING: You must change your Disk Unlock Key" \
        --yesno "You just updated the ROM, which requires resealing TOTP/HOTP secrets.\nTPM released Disk Unlock Key stored in LUKS header must also be regenerated.\n\nIf you did not modify the ROM, this might be a sign of system compromise.\nIn that case, you should say No here and investigate." 30 90) then
    reset_disk_unlock_key
  else
    recovery "User refused to update TOTP/HOTP following what seemed to be a ROM update. Time to investigate changes manually."
  fi
fi

last_half=X
while true; do
  MAIN_MENU_OPTIONS=""
  MAIN_MENU_BG_COLOR=""
  unset totp_confirm
  # detect whether any GPG keys exist in the keyring, if not, initialize that first
  GPG_KEY_COUNT=`gpg -k 2>/dev/null | wc -l`
  if [ $GPG_KEY_COUNT -eq 0 ]; then
    whiptail $CONFIG_ERROR_BG_COLOR --clear --title "ERROR: GPG keyring empty!" \
      --menu "ERROR: Heads couldn't find any GPG keys in your keyring.\n\nIf this is the first time the system has booted,\nyou should add a public GPG key to the BIOS now.\n\nIf you just reflashed a new BIOS, you'll need to add at least one\npublic key to the keyring.\n\nIf you have not just reflashed your BIOS, THIS COULD INDICATE TAMPERING!\n\nHow would you like to proceed?" 30 90 4 \
      'G' ' Add a GPG key to the running BIOS' \
      'i' ' Ignore error and continue to default boot menu' \
      'x' ' Exit to recovery shell' \
      2>/tmp/whiptail || recovery "GUI menu failed"

      totp_confirm=$(cat /tmp/whiptail)
  fi
  
  if [ "$totp_confirm" = "i" -o -z "$totp_confirm" ]; then
    # update the TOTP code every thirty seconds
    date=`date "+%Y-%m-%d %H:%M:%S"`
    seconds=`date "+%s"`
    half=`expr \( $seconds % 60 \) / 30`
    if [ "$CONFIG_TPM" = n ]; then
      TOTP="NO TPM"
    elif [ "$half" != "$last_half" ]; then
      last_half=$half;
      TOTP=`unseal-totp`
      if [ $? -ne 0 ]; then
        #Normal path. We give user a choice.
        whiptail $CONFIG_ERROR_BG_COLOR --clear --title "ERROR: TOTP Generation Failed!" \
          --menu "ERROR: Heads couldn't generate the TOTP code.\n\nIf this is the first time the system has booted, you should reset the TPM\nand set your own password\n\nIf you just reflashed your BIOS, you'll need to generate a new TOTP secret.\n\nIf you have not just reflashed your BIOS, THIS COULD INDICATE TAMPERING!\n\nHow would you like to proceed?" 30 90 4 \
          'g' ' Generate new TOTP/HOTP secret' \
          'i' ' Ignore error and continue to default boot menu' \
          'p' ' Reset the TPM' \
          'x' ' Exit to recovery shell' \
        2>/tmp/whiptail || recovery "GUI menu failed"

        totp_confirm=$(cat /tmp/whiptail)
      fi
    fi
  fi

  if [ "$totp_confirm" = "i" -o -z "$totp_confirm" ]; then 
    if [ -x /bin/libremkey_hotp_verification ]; then
      HOTP=`unseal-hotp`
      enable_usb
      if ! libremkey_hotp_verification info ; then
        whiptail $CONFIG_WARNING_BG_COLOR --clear --title 'WARNING: Please Insert Your Librem Key/Nitrokey' --msgbox "Your Librem Key/Nitrokey was not detected.\n\nPlease insert your Librem Key/Nitrokey" 30 90
        fi
      # Don't output HOTP codes to screen, so as to make replay attacks harder
      libremkey_hotp_verification check "$HOTP"
      case "$?" in
        0 )
          HOTP="Success"
        ;;
        4 )
          HOTP="Invalid code"
          MAIN_MENU_BG_COLOR=$CONFIG_ERROR_BG_COLOR
        ;;
        * )
          HOTP="Error checking code, Insert Librem Key/Nitrokey and retry"
          MAIN_MENU_BG_COLOR=$CONFIG_WARNING_BG_COLOR
        ;;
      esac
    else
      HOTP='N/A'
    fi

    if [ -e /boot/oem ]; then
      check_onboarding_progress
  	  totp_confirm="O"
      echo $totp_confirm > /tmp/whiptail
    else
      whiptail $MAIN_MENU_BG_COLOR --clear --title "$CONFIG_BOOT_GUI_MENU_NAME" \
        --menu "Greenwich Mean Time (GMT) : $date\nTOTP: $TOTP | HOTP: $HOTP" 20 90 10 \
        'y' ' Default boot' \
        'a' ' Advanced Settings -->' \
        'x' ' Exit to recovery shell' \
        2>/tmp/whiptail || recovery "GUI menu failed"
      totp_confirm=$(cat /tmp/whiptail)
    fi
  fi

  if [ "$totp_confirm" = "O" ]; then
    whiptail $MAIN_MENU_BG_COLOR --clear --title "$CONFIG_BOOT_GUI_MENU_NAME: Reownership" \
        --menu "Greenwich Mean Time (GMT) : $date\nTOTP: $TOTP | HOTP: $HOTP" 20 90 10 \
        'C' ' Continue ownership of devices' \
        'x' ' Exit to recovery shell' \
        2>/tmp/whiptail || recovery "GUI menu failed"
      totp_confirm=$(cat /tmp/whiptail)
  fi

  if [ "$totp_confirm" = "C" ]; then
    check_onboarding_progress
  fi

  if [ "$totp_confirm" = "a" ]; then
    whiptail --clear --title "Advanced Settings" \
      --menu "Configure Advanced Settings" 20 90 10 \
      'o' ' Other Boot Options -->' \
      't' ' TPM/TOTP/HOTP Options -->' \
      'G' ' GPG Options -->' \
      'f' ' Flash/Update the BIOS -->' \
      'c' ' Change configuration settings -->' \
      's' ' Update checksums and sign all files in /boot' \
      'R' ' Reencrypt LUKS container' \
      'r' ' <-- Return to main menu' \
      2>/tmp/whiptail || recovery "GUI menu failed"

    totp_confirm=$(cat /tmp/whiptail)
  fi

  if [ "$totp_confirm" = "o" ]; then
    whiptail --clear --title "Other Boot Options" \
      --menu "Select A Boot Option" 20 90 10 \
      'm' ' Show OS boot menu' \
      'u' ' USB boot' \
      'i' ' Ignore tampering and force a boot (Unsafe!)' \
      'r' ' <-- Return to main menu' \
      2>/tmp/whiptail || recovery "GUI menu failed"

    totp_confirm=$(cat /tmp/whiptail)
  fi

  if [ "$totp_confirm" = "t" ]; then
    whiptail --clear --title "TPM/TOTP/HOTP Options" \
      --menu "Select An Option" 20 90 10 \
      'g' ' Generate new TOTP/HOTP secret' \
      'p' ' Reset the TPM' \
      'r' ' TOTP/HOTP does not match, refresh code' \
      'n' ' TOTP/HOTP does not match after refresh, troubleshoot' \
      'r' ' <-- Return to main menu' \
      2>/tmp/whiptail || recovery "GUI menu failed"

    totp_confirm=$(cat /tmp/whiptail)
  fi

  if [ "$totp_confirm" = "x" ]; then
    recovery "User requested recovery shell"
  fi

  if [ "$totp_confirm" = "r" ]; then
    continue
  fi

  if [ "$totp_confirm" = "n" ]; then
    if (whiptail $CONFIG_WARNING_BG_COLOR --title "TOTP/HOTP code mismatched" \
      --yesno "TOTP/HOTP code mismatches could indicate either TPM tampering or clock drift:\n\nTo correct clock drift: 'date -s HH:MM:SS'\nand save it to the RTC: 'hwclock -w'\nthen reboot and try again.\n\nWould you like to exit to a recovery console?" 30 90) then
      echo ""
      echo "To correct clock drift: 'date -s HH:MM:SS'"
      echo "and save it to the RTC: 'hwclock -w'"
      echo "then reboot and try again"
      echo ""
      recovery "TOTP/HOTP mismatch"
    else
      continue
    fi
  fi

  if [ "$totp_confirm" = "u" ]; then
    exec /bin/usb-init
    continue
  fi

  if [ "$totp_confirm" = "g" ]; then
    if (whiptail --title 'Generate new TOTP/HOTP secret' \
        --yesno "This will erase your old secret and replace it with a new one!\n\nDo you want to proceed?" 16 90) then
      update_totp
    else
      echo "Returning to the main menu"
    fi
    continue
  fi

  if [ "$totp_confirm" = "p" ]; then
    if (whiptail --title 'Reset the TPM' \
        --yesno "This will clear the TPM content and reset TPM Owner password.\n\nDo you want to proceed?" 16 90) then
      /bin/tpm-reset
      
      #set flag in oem file
      mount_boot
      if [ -s /boot/oem ];then
        mount -o remount,rw /boot
        echo "tpm_reowned" >> /boot/oem
        mount -o remount,ro /boot
      fi

      # now that the TPM is reset, remove invalid TPM counter files
      mount_boot
      mount -o rw,remount /boot
      rm -f /boot/kexec_rollback.txt

      # create Heads TPM counter before any others
      check_tpm_counter /boot/kexec_rollback.txt \
      || die "Unable to find/create tpm counter"
      counter="$TPM_COUNTER"

      increment_tpm_counter $counter \
      || die "Unable to increment tpm counter"

      sha256sum /tmp/counter-$counter > /boot/kexec_rollback.txt \
      || die "Unable to create rollback file"
      mount -o ro,remount /boot

      update_totp
    else
      echo "Returning to the main menu"
    fi
    continue
  fi

  if [ "$totp_confirm" = "m" ]; then
    # Try to select a kernel from the menu
    mount_boot
    verify_global_hashes
    if [ $? -ne 0 ]; then
      continue
    fi
    kexec-select-boot -m -b /boot -c "grub.cfg" -g
    continue
  fi

  if [ "$totp_confirm" = "i" ]; then
    # Run the menu selection in "force" mode, bypassing hash checks
    if (whiptail $CONFIG_WARNING_BG_COLOR --title 'Unsafe Forced Boot Selected!' \
        --yesno "WARNING: You have chosen to skip all tamper checks and boot anyway.\n\nThis is an unsafe option!\n\nDo you want to proceed?" 16 90) then
      mount_boot
      kexec-select-boot -m -b /boot -c "grub.cfg" -g -f
    else
      echo "Returning to the main menu"
    fi
    continue
  fi

  if [ "$totp_confirm" = "s" ]; then
    update_checksums
    continue
  fi

  if [ "$totp_confirm" = "c" ]; then
    config-gui.sh
    continue
  fi

  if [ "$totp_confirm" = "f" ]; then
    flash-gui.sh
    continue
  fi

  if [ "$totp_confirm" = "G" ]; then
    gpg-gui.sh
    continue
  fi

  if [ "$totp_confirm" = "R" ]; then
    /bin/reencrypt-luks
    continue
  fi

  if [ "$totp_confirm" = "y" -o -n "$totp_confirm" ]; then
    # Try to boot the default
    mount_boot
    verify_global_hashes
    if [ $? -ne 0 ]; then
      continue
    fi
    DEFAULT_FILE=`find /boot/kexec_default.*.txt 2>/dev/null | head -1`
    if [ -r "$DEFAULT_FILE" ]; then
      kexec-select-boot -b /boot -c "grub.cfg" -g \
      || recovery "Failed default boot"
    else
      if (whiptail --title 'No Default Boot Option Configured' \
          --yesno "There is no default boot option configured yet.\nWould you like to load a menu of boot options?\nOtherwise you will return to the main menu." 16 90) then
        kexec-select-boot -m -b /boot -c "grub.cfg" -g
      else
        echo "Returning to the main menu"
      fi
      continue
    fi
  fi

done

recovery "Something failed during boot"
