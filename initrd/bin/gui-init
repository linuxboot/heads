#!/bin/sh
# Boot from a local disk installation

CONFIG_BOOT_GUI_MENU_NAME='Heads Boot Menu'

. /etc/functions
. /etc/config

file_selector() {
  FILE=""
  FILE_LIST=$1
  MENU_MSG=${2:-"Choose the file"}
# create file menu options
  if [ `cat "$FILE_LIST" | wc -l` -gt 0 ]; then
    option=""
    while [ -z "$option" ]
    do
      MENU_OPTIONS=""
      n=0
      while read option
      do
        n=`expr $n + 1`
        option=$(echo $option | tr " " "_")
        MENU_OPTIONS="$MENU_OPTIONS $n ${option}"
      done < $FILE_LIST

      MENU_OPTIONS="$MENU_OPTIONS a Abort"
      whiptail --clear --title "Select your File" \
        --menu "${MENU_MSG} [1-$n, a to abort]:" 20 120 8 \
        -- $MENU_OPTIONS \
        2>/tmp/whiptail || die "Aborting"

      option_index=$(cat /tmp/whiptail)

      if [ "$option_index" = "a" ]; then
        option="a"
        return
      fi

      option=`head -n $option_index $FILE_LIST | tail -1`
      if [ "$option" == "a" ]; then
        return
      fi
    done
    if [ -n "$option" ]; then
      FILE=$option
    fi
  else
    whiptail $CONFIG_ERROR_BG_COLOR --title 'ERROR: No Files Found' \
      --msgbox "No Files found matching the pattern. Aborting." 16 60
    exit 1
  fi
}
select_luks_container()
{
  if [ -s /boot/kexec_key_devices.txt ]; then
    LUKS=$(cut -d ' ' -f1 /boot/kexec_key_devices.txt)
  else
    #generate a list of devices to choose from that contain a LUKS header
      blkid | cut -d ':' -f 1 | while read device;do cryptsetup isLuks $device;if [ $(echo $?) == 0 ]; then echo $device;fi; done | sort > /tmp/luks_devices.txt
      file_selector "/tmp/luks_devices.txt" "Select LUKS container device"
    if [ "$FILE" == "" ]; then
      return
    else
      LUKS=$FILE
      mount_boot
      mount -o remount,rw /boot
      echo "$LUKS $(cryptsetup luksUUID $LUKS)" > /boot/kexec_key_devices.txt
      mount -o remount,ro /boot
    fi
  fi
}
mount_boot()
{
  # Mount local disk if it is not already mounted
  if ! grep -q /boot /proc/mounts ; then
    mount -o ro /boot \
      || recovery "Unable to mount /boot"
  fi
}
verify_global_hashes()
{
  # Check the hashes of all the files, ignoring signatures for now
  check_config /boot force
  TMP_HASH_FILE="/tmp/kexec/kexec_hashes.txt"
  TMP_PACKAGE_TRIGGER_PRE="/tmp/kexec/kexec_package_trigger_pre.txt"
  TMP_PACKAGE_TRIGGER_POST="/tmp/kexec/kexec_package_trigger_post.txt"

  if cd /boot && sha256sum -c "$TMP_HASH_FILE" > /tmp/hash_output ; then
    return 0
  elif [ ! -f $TMP_HASH_FILE ]; then
    if (whiptail $CONFIG_ERROR_BG_COLOR --clear --title 'ERROR: Missing Hash File!' \
      --yesno "The file containing hashes for /boot is missing!\n\nIf you are setting this system up for the first time, select Yes to update\nyour list of checksums.\n\nOtherwise this could indicate a compromise and you should select No to\nreturn to the main menu.\n\nWould you like to update your checksums now?" 30 90) then
      update_checksums
    fi
    return 1
  else
    CHANGED_FILES=$(grep -v 'OK$' /tmp/hash_output | cut -f1 -d ':')

    # if files changed before package manager started, show stern warning
    if [ -f "$TMP_PACKAGE_TRIGGER_PRE" ]; then 
      PRE_CHANGED_FILES=$(grep '^CHANGED_FILES' $TMP_PACKAGE_TRIGGER_POST | cut -f 2 -d '=' | tr -d '"')
      TEXT="The following files failed the verification process BEFORE package updates ran:\n${PRE_CHANGED_FILES}\n\nCompare against the files Heads has detected have changed:\n${CHANGED_FILES}\n\nThis could indicate a compromise!\n\nWould you like to update your checksums anyway?"

    # if files changed after package manager started, probably caused by package manager
    elif [ -f "$TMP_PACKAGE_TRIGGER_POST" ]; then 
      LAST_PACKAGE_LIST=$(grep -E "^(Install|Remove|Upgrade|Reinstall):" $TMP_PACKAGE_TRIGGER_POST)
      UPDATE_INITRAMFS_PACKAGE=$(grep '^UPDATE_INITRAMFS_PACKAGE' $TMP_PACKAGE_TRIGGER_POST | cut -f 2 -d '=' | tr -d '"')

      if [ "$UPDATE_INITRAMFS_PACKAGE" != "" ]; then
        TEXT="The following files failed the verification process AFTER package updates ran:\n${CHANGED_FILES}\n\nThis is likely due to package triggers in$UPDATE_INITRAMFS_PACKAGE.\n\nYou will need to update your checksums for all files in /boot.\n\nWould you like to update your checksums now?"
      else
        TEXT="The following files failed the verification process AFTER package updates ran:\n${CHANGED_FILES}\n\nThis might be due to the following package updates:\n$LAST_PACKAGE_LIST.\n\nYou will need to update your checksums for all files in /boot.\n\nWould you like to update your checksums now?"
      fi

    else
      TEXT="The following files failed the verification process:\n${CHANGED_FILES}\n\nThis could indicate a compromise!\n\nWould you like to update your checksums now?"
    fi

    if (whiptail $CONFIG_ERROR_BG_COLOR --clear --title 'ERROR: Boot Hash Mismatch' --yesno "$TEXT" 30 90) then
      update_checksums
    fi
    return 1
  fi
}
update_checksums()
{
  if (whiptail --title 'Update Checksums and sign all files in /boot' \
      --yesno "You have chosen to update the checksums and sign all of the files in /boot.\n\nThis means that you trust that the files in /boot have not been tampered\n with.\n\nYou will need your GPG key to continue and this change will modify your\n disk.\n\nDo you want to continue?" 16 90) then
    mount_boot
    mount -o rw,remount /boot

    cd /boot
    find ./ -type f ! -name '*kexec*' | xargs sha256sum > /boot/kexec_hashes.txt
    DEFAULT_FILES=$(cat /boot/kexec_default_hashes.txt | cut -f3 -d ' ')
    echo $DEFAULT_FILES | xargs sha256sum > /boot/kexec_default_hashes.txt

    # Remove any package trigger log files
    # We don't need them after the user decides to sign
    rm -f /boot/kexec_package_trigger*

    # sign and auto-roll config counter
    extparam=
    if [ "$CONFIG_TPM" = "y" ]; then
      extparam=-u
    fi
    kexec-sign-config -p /boot $extparam \
    || die "Failed to sign default config"

    if [ -e /boot/oem ];then
      mount -o remount,rw /boot
      echo "checksums_updated" >> /boot/oem
      mount -o remount,ro /boot
    fi
    # switch back to ro mode
    mount -o ro,remount /boot
  else
    echo "Returning to the main menu"
  fi
}
update_totp()
{
  echo "Scan the QR code to add the new TOTP secret"
  /bin/seal-totp
  if [ -x /bin/libremkey_hotp_verification ]; then
    echo "Once you have scanned the QR code, hit Enter to configure your Librem Key"
    read
    /bin/seal-libremkey
  else
    echo "Once you have scanned the QR code, hit Enter to reboot"
    read
  fi
  /bin/reboot
}
check_onboarding_progress()
{
  mount_boot
  if [[ -e /boot/oem ]];then
    res=$(grep luks_reencrypted /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      reownership_state="luks_reencryption"
      totp_confirm="R"
      echo $totp_confirm > /tmp/whiptail
      return
    fi
    res=$(grep luks_passwd_changed /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      reownership_state="luks_password_change"
      totp_confirm="R"
      return
    fi
    res=$(grep gpg_factory_resetted /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      reownership_state="gpg_factory_reset"
      totp_confirm="F"
      echo $totp_confirm > /tmp/whiptail
      return
    fi
    res=$(grep tpm_reowned /boot/oem 2>&1 > /dev/null)
    if [ $? -ne 0 ];then
      totp_confirm="p"
      echo $totp_confirm > /tmp/whiptail
      return
    fi
    if [ $(grep -E "luks_reencrypted|luks_passwd_changed|gpg_factory_resetted|tpm_reowned" /boot/oem | wc -l) -eq 4 ];then
      if [ $HOTP = "Success" ];then
        mount -o remount,rw /boot
        rm /boot/oem
        rm /boot/kexec_*hashes*
        mount -o remount,ro /boot
        unset reownership_state

        whiptail --title 'DISK UNLOCK KEY ADVICE 1/3' --msgbox \
        "***You SHOULD SET a Disk unlock key for your own data privacy!!!***\n\nDoing so, a witness will only be able to type observed Disk unlock\n passphrase from this computer and won't be able on a cloned\n copy of this disk.\n\nThe release of Disk unlock key happens ONLY if TPM attests firmware\nintegrity, and only if Disk unlock user passphrase is valid.\n\nPlease hit Enter to continue" 30 60

        whiptail --title 'DISK UNLOCK KEY ADVICE 2/3' --msgbox \
        "Otherwise, typing your Disk Recovery key passphrase at boot puts you\nat risk. Someone could clone your disk and type that witnessed\npassphrase and access your data both locally and from a cloned\ndisk.\n\nThis is why strong passphrases are so important to data privacy.\nCONSIDER YOURSELF WARNED.\n\nPlease hit Enter to continue" 30 60

        whiptail --title 'DISK UNLOCK KEY ADVICE 3/3' --msgbox \
        "To set Disk Unlock Key, released by the TPM only if firmware integrity\n is attested and when combined with a valid passphrase:\n\nSelect from Main menu:\n\nAdvanced Options menu -> Other Boot Options -> Show OS boot menu\n1-Then select the first boot option proposed (dynamic option)\n2-Then,answer Y when asked to add disk encryption to the TPM.\n\nYou will be asked to set one in the following step.\n\nPlease hit Enter to continue" 30 60
        
       else
        #Deal with corner case where after inserting key in previous step, HTOP seal fails with provided good password.
        #In that case, we regenerate HOTP and TOTP
        totp_confirm="g"
        echo $totp_confirm > /tmp/whiptail
      fi
    fi
    elif [ ! -e /boot/oem ];then
      #no oem file. Normal boot.
      res=$(grep checksums_updated /boot/oem 2>&1 > /dev/null)
      if [ $? -ne 0 ];then
        #Here we hijack the normal boot process, so that we resign all files before normal boot complaints about a missing /boot/oem file
        verify_global_hashes
      return
    fi
      unset totp_confirm
    fi
}

last_half=X
while true; do
  MAIN_MENU_OPTIONS=""
  MAIN_MENU_BG_COLOR=""
  unset totp_confirm
  # detect whether any GPG keys exist in the keyring, if not, initialize that first
  GPG_KEY_COUNT=`gpg -k 2>/dev/null | wc -l`
  if [ $GPG_KEY_COUNT -eq 0 ]; then
    whiptail $CONFIG_ERROR_BG_COLOR --clear --title "ERROR: GPG keyring empty!" \
      --menu "ERROR: Heads couldn't find any GPG keys in your keyring.\n\nIf this is the first time the system has booted,\nyou should add a public GPG key to the BIOS now.\n\nIf you just reflashed a new BIOS, you'll need to add at least one\npublic key to the keyring.\n\nIf you have not just reflashed your BIOS, THIS COULD INDICATE TAMPERING!\n\nHow would you like to proceed?" 30 90 4 \
      'f' ' Add a GPG key to the running BIOS' \
      'F' ' Factory reset, own GPG card, generate and add key into running BIOS' \
      'i' ' Ignore error and continue to default boot menu' \
      'x' ' Exit to recovery shell' \
      2>/tmp/whiptail || recovery "GUI menu failed"

      totp_confirm=$(cat /tmp/whiptail)
  fi
  if [ "$totp_confirm" = "i" -o -z "$totp_confirm" ]; then
    # update the TOTP code every thirty seconds
    date=`date "+%Y-%m-%d %H:%M:%S"`
    seconds=`date "+%s"`
    half=`expr \( $seconds % 60 \) / 30`
    if [ "$CONFIG_TPM" = n ]; then
      TOTP="NO TPM"
    elif [ "$half" != "$last_half" ]; then
      last_half=$half;
      TOTP=`unseal-totp`
      if [ $? -ne 0 ]; then
        whiptail $CONFIG_ERROR_BG_COLOR --clear --title "ERROR: TOTP Generation Failed!" \
          --menu "ERROR: Heads couldn't generate the TOTP code.\n\nIf this is the first time the system has booted, you should reset the TPM\nand set your own password\n\nIf you just reflashed your BIOS, you'll need to generate a new TOTP secret.\n\nIf you have not just reflashed your BIOS, THIS COULD INDICATE TAMPERING!\n\nHow would you like to proceed?" 30 90 4 \
          'g' ' Generate new TOTP/HOTP secret' \
          'i' ' Ignore error and continue to default boot menu' \
          'p' ' Reset the TPM' \
          'x' ' Exit to recovery shell' \
          2>/tmp/whiptail || recovery "GUI menu failed"

        totp_confirm=$(cat /tmp/whiptail)
      fi
    fi
  fi

  if [ "$totp_confirm" = "i" -o -z "$totp_confirm" ]; then 
    if [ -x /bin/libremkey_hotp_verification ]; then
      HOTP=`unseal-hotp`
      enable_usb
      if ! libremkey_hotp_verification info ; then
        whiptail $CONFIG_WARNING_BG_COLOR --clear --title 'WARNING: Please Insert Your Librem Key' --msgbox "Your Librem Key was not detected.\n\nPlease insert your Librem Key" 30 90
        fi
      # Don't output HOTP codes to screen, so as to make replay attacks harder
      libremkey_hotp_verification check $HOTP
      case "$?" in
        0 )
          HOTP="Success"
        ;;
        4 )
          HOTP="Invalid code"
          MAIN_MENU_BG_COLOR=$CONFIG_ERROR_BG_COLOR
        ;;
        * )
          HOTP="Error checking code, Insert Librem Key and retry"
          MAIN_MENU_BG_COLOR=$CONFIG_WARNING_BG_COLOR
        ;;
      esac
    else
      HOTP='N/A'
    fi

    if [[ -e /boot/oem ]] && [[ ! -s /boot/oem ]] ;then
      #oem empty file found. Show Onboarding menu once.
      whiptail --title 'Hardware reownership Wizard' --msgbox \
        "The received hardware is currently owned by your OEM. We will change that.\n\nOn the next screen, MAKE SURE THAT THE HOTP CODE IS: 'Success'\\nIf it's not, reboot your hardware with your Librem/Nitrokey inserted.\nIf the HOTP code is still invalid, return received hardware back to OEM.\n\nThis Wizard would otherwise make you own your own hardware by:\n1-Reencrypting encrypted drive content (LUKS container)\n2-Changing LUKS Recovery key and it's passphrase\n3-Resetting your LibremKey/Nitrokey Pro v2 to factory defaults\n4-Setting User (PIN) and Admin passwords into your LibremKey/NitroKey\n4-Generating keys in it, exporting public key and\n importing it in the rom prior to reprogramming the SPI flash with it\n5-Own your Trusted Platform Module (TPM)\n6-Take integrity measures of all /boot files and sign the resulting\n checksum file with yourLibremKey/Nitrokey Pro\n\nPress the Enter key to continue." 30 60
      totp_confirm="O"
      echo $totp_confirm > /tmp/whiptail
      mount -o remount,rw /boot
      echo "onboarding" >> /boot/oem
      mount -o remount,ro /boot
    elif [[ -s /boot/oem ]];then
      check_onboarding_progress
    	totp_confirm="O"
      echo $totp_confirm > /tmp/whiptail
    else
      whiptail $MAIN_MENU_BG_COLOR --clear --title "$CONFIG_BOOT_GUI_MENU_NAME" \
        --menu "$date\nTOTP: $TOTP | HOTP: $HOTP" 20 90 10 \
        'y' ' Default boot' \
        'a' ' Advanced Settings -->' \
        'x' ' Exit to recovery shell' \
        2>/tmp/whiptail || recovery "GUI menu failed"
      totp_confirm=$(cat /tmp/whiptail)
    fi
  fi

  if [ "$totp_confirm" = "O" ]; then
    whiptail $MAIN_MENU_BG_COLOR --clear --title "$CONFIG_BOOT_GUI_MENU_NAME: Reownership" \
        --menu "$date\nTOTP: $TOTP | HOTP: $HOTP" 20 90 10 \
        'C' ' Continue ownership of devices' \
        'x' ' Exit to recovery shell' \
        2>/tmp/whiptail || recovery "GUI menu failed"
      totp_confirm=$(cat /tmp/whiptail)
  fi

  if [ "$totp_confirm" = "C" ]; then
    check_onboarding_progress
  fi

  if [ "$totp_confirm" = "a" ]; then
    whiptail --clear --title "Advanced Settings" \
      --menu "Configure Advanced Settings" 20 90 10 \
      'o' ' Other Boot Options -->' \
      'r' ' TOTP/HOTP does not match, refresh code' \
      'g' ' Generate new TOTP/HOTP secret' \
      's' ' Update checksums and sign all files in /boot' \
      'f' ' Flash/Update the BIOS -->' \
      'p' ' Reset the TPM' \
      'F' ' Factory reset LibremKey/Nitrokey Pro v2' \
      'R' ' Reencrypt LUKS container' \
      'n' ' TOTP/HOTP does not match after refresh, troubleshoot' \
      'r' ' <-- Return to main menu' \
      2>/tmp/whiptail || recovery "GUI menu failed"

    totp_confirm=$(cat /tmp/whiptail)
  fi

  if [ "$totp_confirm" = "o" ]; then
    whiptail --clear --title "Other Boot Options" \
      --menu "Select A Boot Option" 20 90 10 \
      'm' ' Show OS boot menu' \
      'u' ' USB boot' \
      'i' ' Ignore tampering and force a boot (Unsafe!)' \
      'r' ' <-- Return to main menu' \
      2>/tmp/whiptail || recovery "GUI menu failed"

    totp_confirm=$(cat /tmp/whiptail)
  fi

  if [ "$totp_confirm" = "x" ]; then
    recovery "User requested recovery shell"
  fi

  if [ "$totp_confirm" = "r" ]; then
    continue
  fi

  if [ "$totp_confirm" = "n" ]; then
    if (whiptail $CONFIG_WARNING_BG_COLOR --title "TOTP/HOTP code mismatched" \
      --yesno "TOTP/HOTP code mismatches could indicate either TPM tampering or clock drift:\n\nTo correct clock drift: 'date -s HH:MM:SS'\nand save it to the RTC: 'hwclock -w'\nthen reboot and try again.\n\nWould you like to exit to a recovery console?" 30 90) then
      echo ""
      echo "To correct clock drift: 'date -s HH:MM:SS'"
      echo "and save it to the RTC: 'hwclock -w'"
      echo "then reboot and try again"
      echo ""
      recovery "TOTP/HOTP mismatch"
    else
      continue
    fi
  fi

  if [ "$totp_confirm" = "u" ]; then
    exec /bin/usb-init
    continue
  fi

  if [ "$totp_confirm" = "g" ]; then
    if (whiptail --title 'Generate new TOTP/HOTP secret' \
        --yesno "This will erase your old secret and replace it with a new one!\n\nDo you want to proceed?" 16 90) then
      update_totp
    else
      echo "Returning to the main menu"
    fi
    continue
  fi

  if [ "$totp_confirm" = "p" ]; then
    if (whiptail --title 'Reset the TPM' \
        --yesno "This will clear the TPM and TPM password, replace them with new ones!\n\nDo you want to proceed?" 16 90) then
      /bin/tpm-reset
      
      #set flag in oem file
      mount_boot
      if [ -s /boot/oem ];then
        mount -o remount,rw /boot
        echo tpm_reowned >> /boot/oem
        mount -o remount,ro /boot
      fi

      # now that the TPM is reset, remove invalid TPM counter files
      mount_boot
      mount -o rw,remount /boot
      rm -f /boot/kexec_rollback.txt

      # create Heads TPM counter before any others
      check_tpm_counter /boot/kexec_rollback.txt \
      || die "Unable to find/create tpm counter"
      counter="$TPM_COUNTER"

      increment_tpm_counter $counter \
      || die "Unable to increment tpm counter"

      sha256sum /tmp/counter-$counter > /boot/kexec_rollback.txt \
      || die "Unable to create rollback file"
      mount -o ro,remount /boot

      update_totp
    else
      echo "Returning to the main menu"
    fi
    continue
  fi

  if [ "$totp_confirm" = "m" ]; then
    # Try to select a kernel from the menu
    mount_boot
    verify_global_hashes
    if [ $? -ne 0 ]; then
      continue
    fi
    kexec-select-boot -m -b /boot -c "grub.cfg" -g
    continue
  fi

  if [ "$totp_confirm" = "i" ]; then
    # Run the menu selection in "force" mode, bypassing hash checks
    if (whiptail $CONFIG_WARNING_BG_COLOR --title 'Unsafe Forced Boot Selected!' \
        --yesno "WARNING: You have chosen to skip all tamper checks and boot anyway.\n\nThis is an unsafe option!\n\nDo you want to proceed?" 16 90) then
      mount_boot
      kexec-select-boot -m -b /boot -c "grub.cfg" -g -f
    else
      echo "Returning to the main menu"
    fi
    continue
  fi

  if [ "$totp_confirm" = "s" ]; then
    update_checksums
    continue
  fi

  if [ "$totp_confirm" = "f" ]; then
    flash-gui.sh
    continue
  fi
  
  if [ "$totp_confirm" = "F" ]; then
    if (whiptail $CONFIG_WARNING_BG_COLOR --clear --title 'Factory Reset and reownership of GPG card' \
        --yesno "You are about to factory reset your GPG card!\n\nThis will:\n 1-Wipe all PRIVATE keys that were previously kept inside GPG card\n 2-Set default key size to 4096 bits (maximum)\n 3-Ask you to choose two passwords to interact with the card:\n  3.1: An admininstrative passphrase used to manage the card\n  3.2: A user passphrase (PIN) used everytime you sign\n   encrypt/decrypt content\n4-Generate new Encryption, Signing and Authentication keys\n  inside your GPG card\n5-Export associated public key, replace the one being\n  present and trusted inside running BIOS, and reflash\n  SPI flash with resulting rom image.\n\nAs a result, the running BIOS will be modified.\n\nWould you like to continue?" 30 90) then
      
      #TODO: Circumvent permission bug with mkdir and chmod permitting to use gpg --home=/media/gpg_keys directly. 
      #Cannot create a new gpg homedir with right permissions nor chmod 700 that directory.
      #Meanwhile, we reuse /.gnupg by temporarely deleting it's existing content.
      rm -rf .gnupg/*

      #Setting new passwords
      gpgcard_user_pass1=1
      gpgcard_user_pass2=2
      gpgcard_admin_pass1=3
      gpgcard_admin_pass2=4

      while [[ "$gpgcard_user_pass1" != "$gpgcard_user_pass2" ]] || [[ ${#gpgcard_user_pass1} -lt 6 || ${#gpgcard_user_pass1} -gt 20 ]];do
      {
        echo -e "Choose your new GPG card user password that will be typed when using GPG smartcard (Sign files, encrypt emails and files).\nIt needs to be a least 6 but not more then 20 characters:"
        read -s gpgcard_user_pass1
        echo "Retype user passphrase:"
        read -s gpgcard_user_pass2
        if [[ "$gpgcard_user_pass1" != "$gpgcard_user_pass2" ]]; then echo "Passwords typed were different."; fi
      };done
      gpgcard_user_pass=$gpgcard_user_pass1

      while [[ "$gpgcard_admin_pass1" != "$gpgcard_admin_pass2" ]] || [[ ${#gpgcard_admin_pass1} -lt 8 || ${#gpgcard_admin_pass1} -gt 20 ]]; do
      {
        echo -e "\nChoose your new GPG card admin password that will be typed when managing GPG smartcard (HTOP sealing, managing key, etc).\nIt needs to be a least 8 but not more then 20 characters:"
        read -s gpgcard_admin_pass1
        echo "Retype admin password:"
        read -s gpgcard_admin_pass2

        if [[ "$gpgcard_admin_pass1" != "$gpgcard_admin_pass2" ]]; then echo "Passwords typed were different."; fi
      };done
      gpgcard_admin_pass=$gpgcard_admin_pass1
 
      echo -e "\n\n"
      echo -e "We will generate a GnuPG (GPG) keypair identifiable with the following text form:"
      echo -e "Real Name (Comment) email@address.org\n"
      echo -e "Enter your Real Name:"
      read gpgcard_real_name
      echo "Enter your email@adress.org:"
      read gpgcard_email_address
      echo "Enter Comment (To distinguish this key from others with same previous attributes):"
      read gpgcard_comment

      whiptail $CONFIG_WARNING_BG_COLOR --clear --title 'WARNING: Please Insert A USB Disk' --msgbox \
      "Please insert a USB disk on which you want to store your GPG public key\n and trustdb.\n\nThose will be backuped under the 'gpg_keys' directory.\n\nPress the Enter key to continue." 30 90     
      
      #TODO whiptail warning loop
      mount-usb

      #Copy generated public key, private_subkey, trustdb and artifacts to external media for backup:
      mount -o remount,rw /media

      #backup existing /media/gpg_keys directory
      if [ -d /media/gpg_keys ];then
        newdir="/media/gpg_keys-$(date '+%Y-%m-%d-%H_%M_%S')"
        echo "Backing up /media/gpg_keys into $newdir"
        mv /media/gpg_keys $newdir
      fi

      mkdir -p /media/gpg_keys
    
      confirm_gpg_card
      {
        echo admin
        echo factory-reset
        echo y
        echo yes
      } | gpg --command-fd=0 --status-fd=1 --pinentry-mode=loopback --card-edit --home=/.gnupg/

      #Setting new admin and user passwords in GPG card
      {
        echo admin
        echo passwd
        echo 1
        echo 123456 #Default user password after factory reset of card
        echo "$gpgcard_user_pass"
        echo "$gpgcard_user_pass"
        echo 3
        echo 12345678 #Default administrator password after factory reset of card
        echo "$gpgcard_admin_pass"
        echo "$gpgcard_admin_pass"
        echo Q
      } | gpg --command-fd=0 --status-fd=2 --pinentry-mode=loopback --card-edit --home=/.gnupg/

      #Set GPG card key attributes key sizes to 4096 bits
      {
        echo admin
        echo key-attr
        echo 1 # RSA
        echo 4096 #Signing key size set to maximum supported by SmartCard
        echo "$gpgcard_admin_pass"
        echo 1 # RSA
        echo 4096 #Encryption key size set to maximum supported by SmartCard
        echo "$gpgcard_admin_pass"
        echo 1 # RSA
        echo 4096 #Authentication key size set to maximum supported by SmartCard
        echo "$gpgcard_admin_pass"
      } | gpg --command-fd=0 --status-fd=2 --pinentry-mode=loopback --card-edit --home=/.gnupg/

      #Generate Encryption, Signing and Authentication keys
      whiptail --clear --title 'GPG card key generation' --msgbox \
        "BE PATIENT! Generating 4096 bits Encryption, Signing and Authentication\n keys take around 5 minutes each! Be prepared to patient around 15 minutes!\n\nPress the Enter Key to continue" 30 90

      {
        echo admin
        echo generate
        echo n
        echo "$gpgcard_admin_pass"
        echo "$gpgcard_user_pass"
        echo 1y
        echo "$gpgcard_real_name"
        echo "$gpgcard_email_address"
        echo "$gpgcard_comment"
      } | gpg --command-fd=0 --status-fd=2 --pinentry-mode=loopback --card-edit --home=/.gnupg/

      #Export and inject public key and trustdb export into extracted rom with current user keys being wiped
      rom=/tmp/coreboot.rom

      #remove invalid kexec_* signed files
      mount_boot
      mount -o remount,rw /boot
      rm /boot/kexec*
      mount -o remount,ro /boot

      gpg --home=/.gnupg/ --export --armor $gpgcard_email_address  > /media/gpg_keys/public.key
      gpg --home=/.gnupg/ --export-ownertrust > /media/gpg_keys/otrust.txt
      cp -r ./.gnupg/* /media/gpg_keys/ 2> /dev/null
    
      #Flush changes to external media:
      mount -o remount,ro /media

      #Read rom
      flash.sh -r $rom

      #delete public gpg keys and otrust (trustdb) in extracted running rom
      cbfs -o $rom --list|grep -e pubring -e trustdb -e otrust -e public|while read file; do cbfs -o $rom -d $file;done

      #Insert public key and trustdb exports into reproducible rom:
      cbfs -o $rom -a "heads/initrd/.gnupg/keys/public.key" -f /media/gpg_keys/public.key
      cbfs -o $rom -a "heads/initrd/.gnupg/keys/otrust.txt" -f /media/gpg_keys/otrust.txt

      #flash back a "clean" rom with public key and trustdb into SPI flash
      flash.sh -c $rom

      if [ -s /boot/oem ];then
        mount -o remount,rw /boot
        echo gpg_factory_resetted >> /boot/oem
        mount -o remount,ro /boot
      fi
      
      whiptail $CONFIG_WARNING_BG_COLOR --clear --title 'WARNING: Reboot required' --msgbox \
        "A reboot is required.\n\n Your firmware has been reflashed with your own public key and trustdb\n included.\n\n Heads will detect it and react accordingly:\n It will ask you to regenerate a new TOTP/HOTP code (seal BIOS integrity),\n take /boot integrity measures and sign them with your freshly\n factory resetted GPG card user password (PIN).\n\nPress the Enter key to continue." 30 90
      /bin/reboot
    else
      echo "Returning to the previous menu"
    fi
   continue 
  fi

  if [ "$totp_confirm" = "R" ]; then
    if [[ -z $reownership_state ]] || [[ $reownership_state = "luks_reencryption" ]]; then 
      whiptail --title 'Reencrypt LUKS container with a new user selected strong passphrase?' \
          --msgbox "This will replace the actual Disk recovery key.\n\nThe passphrase associated with this key will be asked to the user in the\n following conditions:\n1-Every boot if no Disk unlock key was added to the TPM\n2-If the TPM fails (Hardware failure)\n3-If the firmware has been tampered with/upgraded/modified by the user\n\nThis process requires you to type the actual Disk recovery key passphrase\nand will delete the actual Disk unlock key released by the TPM into\nLUKS (slot 1) if present.\n\nAt the next prompt, you may be asked to select which file corresponds to\nthe LUKS device container. Normally, it should be /dev/sda2.\n\nPress the Enter key." 30 90
    
      select_luks_container
    
      whiptail --title 'Reencrypting LUKS container!' --msgbox \
      "Please enter current Recovery key passphrase (slot 0) to reencrypt\n LUKS container with a brand new encryption key\n\nPress Enter to continue." 30 60
      cryptsetup-reencrypt -B 32 --use-directio $LUKS --key-slot 0
      
      if [ $(echo $?) -ne 0 ]; then
        whiptail --title 'Invalid LUKS passphrase?' --msgbox \
          "The LUKS Recovery password was provided to you by the OEM over secure\ncommunication channel.\n\nIf you previously changed it and do not remember it,\n you will have to reinstall Linux OS from a USB drive.\n\nTo do so, place ISO file with it's signature file on root of USB drive,\n and select Boot from USB\n\nPlease press Enter to continue." 30 60
        continue
      else
        #Successfully reencrypted LUKS container with current Recovery key passphrase. Write successful state in oem file
        if [ -e /boot/oem ];then
          mount -o remount,rw /boot
          echo "luks_reencrypted" >> /boot/oem
          reownership_state="luks_password_change"
          mount -o remount,ro /boot
        fi
      fi
    fi

    if [[ -z $reownership_state ]] || [[ $reownership_state == "luks_password_change" ]]; then
      whiptail --title 'Changing LUKS Recovery key passphrase' --msgbox \
        "Please enter current Recovery key passphrase (slot 0).\nThen choose a strong passphrase of your own.\n\n**DICEWARE passphrase methodology is STRONGLY ADVISED.**\n\nPlease hit Enter to continue" 30 60

      select_luks_container
    
      cryptsetup luksChangeKey $LUKS --key-slot 0 --tries 3
      if [ $(echo $?) -ne 0 ]; then
        whiptail --title 'Invalid LUKS passphrase?' --msgbox \
          "The LUKS Recovery password was provided to you by the OEM over secure channel.\nIf you previously changed it and do not remember it,\n you will have to reinstall Linux OS from a USB drive.\nTo do so, put OS ISO file with it's signature file on USB drive,\n And select Boot from USB\n\nPlease press Enter to continue." 30 60
        continue
      else
        #Successfully changed passphrase of LUKS Recovery key. Write successful state in oem file
        if [ -e /boot/oem ];then
          mount -o remount,rw /boot
          echo "luks_passwd_changed" >> /boot/oem
          mount -o remount,ro /boot
        fi
      fi
      continue
    fi
  fi

  if [ "$totp_confirm" = "y" -o -n "$totp_confirm" ]; then
    # Try to boot the default
    mount_boot
    verify_global_hashes
    if [ $? -ne 0 ]; then
      continue
    fi
    DEFAULT_FILE=`find /boot/kexec_default.*.txt 2>/dev/null | head -1`
    if [ -r "$DEFAULT_FILE" ]; then
      kexec-select-boot -b /boot -c "grub.cfg" -g \
      || recovery "Failed default boot"
    else
      if (whiptail --title 'No Default Boot Option Configured' \
          --yesno "There is no default boot option configured yet.\nWould you like to load a menu of boot options?\nOtherwise you will return to the main menu." 16 90) then
        kexec-select-boot -m -b /boot -c "grub.cfg" -g
      else
        echo "Returning to the main menu"
      fi
      continue
    fi
  fi

done

recovery "Something failed during boot"
