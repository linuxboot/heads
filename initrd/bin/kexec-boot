#!/bin/sh
# Launches kexec from saved configuration entries

usage() {
	cat <<End-of-message
Usage
=====

Launches kexec from saved configuration entries
	
$0 -b /boot -e 'kexec params|...|...' [<options>]
	
Options
-------

### -a <additional configurations>

Anything provided to the -a argument is appended to the kernel command line.  kernel option add statements normally come from the board configuration to pass board specific tweaks at the OS level.

FOR EXAMPLE

	-a 'intel_iommu=on intel_iommu=igfx_off'

### -b <boot path>

path to boot files.  e.g.  -b /boot

### -e <kexec params>

used to prepare parameters passed to kexec system call for booting operating systems on disk.  Fields are pipe separated. 

	"<description>|[elf,xen,multiboot]|kernel <path>|initrd <path>|<parameters>"

First field is ignored.  The second field is the type of booting.  See examples below.

The other fields are kernel, initrd, and parameters to pass to the linux kernel.

EXAMPLE 1: ELF

boot a linux kernel and specify the root partition

	-e "my custom boot|elf|kernel /vmlinuz|initrd /initrd.img|append root=/dev/sda1"

EXAMPLE 2: XEN

boot Qubes, with Xen hypervisor

	-e "xen boot|xen|module /vmlinuz|module /vmlinuz-4.4.67-13.x86_64 placeholder root=/dev/mapper/root ro|module /initramfs-4.4.67-13.x86_64.img"

EXAMPLE 3: MULTIBOOT

boot Qubes, with Xen hypervisor and LUKS encrypted root partition

	-e "Qubes, with Xen hypervisor|multiboot|kernel /xen-4.6.5.gz placeholder |module /vmlinuz-4.4.67-13.pvops.qubes.x86_64 placeholder root=/dev/mapper/luks-UUID ro rd.qubes.hide_all_usb|module /initramfs-4.4.67-13.pvops.qubes.x86_64.img"

Currently, any multiboot entry is interpreted as a Xen-variant and kexec-boot overrides the arguments to the multiboot kernel with custom arguments. 

### -f

some sort of debug mode which prints information about files and sets dryrun on

### -h

show help

### -i

Use this parameter to ignore the verification of boot hashes and rollback counter.  This will boot a potentially compromised system.

### -o <initrd>

use the specified initrd for booting

### -r <configurations to remove>

kernel option remove statements normally come from board configuration to pass board specific tweaks at the OS level.  Anything provided to the -r argument is removed from the kernel command line. 

For EXAMPLE:

	-r 'quiet'

In this case 'quiet' will be removed from the kernel command line before it is booted.

End-of-message
}

dryrun="n"
printfiles="n"
printinitrd="n"
while getopts "b:e:r:a:o:fih" arg; do
	case $arg in
		b) bootdir="$OPTARG" ;;
		e) entry="$OPTARG" ;;
		r) cmdremove="$OPTARG" ;;
		a) cmdadd="$OPTARG" ;;
		o) override_initrd="$OPTARG" ;;
		f) dryrun="y"; printfiles="y" ;;
		i) dryrun="y"; printinitrd="y" ;;
		h) usage; exit 1;;
	esac
done

set -e -o pipefail
. /tmp/config
. /etc/functions

if [ -z "$bootdir" ]; then
	usage
	die "-b <boot> is required"
fi
if [ -z "$entry" ]; then
	usage
	die "-e <boot entry> is required"
fi

bootdir="${bootdir%%/}"

kexectype=`echo $entry | cut -d\| -f2`
kexecparams=`echo $entry | cut -d\| -f3- | tr '|' '\n'`
kexeccmd="kexec"

cmdadd="$CONFIG_BOOT_KERNEL_ADD $cmdadd"
cmdremove="$CONFIG_BOOT_KERNEL_REMOVE $cmdremove"

fix_file_path() {
	if [ "$printfiles" = "y" ]; then
		# output file relative to local boot directory
		echo ".$firstval"
	fi

	filepath="$bootdir$firstval"

	if ! [ -r $filepath ]; then
		die "Failed to find file $firstval"
	fi
}

adjusted_cmd_line="n"
adjust_cmd_line() {
	if [ -n "$cmdremove" ]; then
		for i in $cmdremove; do
			cmdline=$(echo $cmdline | sed "s/\b$i\b//g")
		done
	fi

	if [ -n "$cmdadd" ]; then
		cmdline="$cmdline $cmdadd"
	fi
	adjusted_cmd_line="y"
}

module_number="1"
while read line
do
	key=`echo $line | cut -d\  -f1`
	firstval=`echo $line | cut -d\  -f2`
	restval=`echo $line | cut -d\  -f3-`
	if [ "$key" = "kernel" ]; then
		fix_file_path
		if [ "$kexectype" = "xen" ]; then
			# always use xen with custom arguments
			kexeccmd="$kexeccmd -l $filepath"
			kexeccmd="$kexeccmd --command-line \"$restval no-real-mode reboot=no vga=current\""
		elif [ "$kexectype" = "multiboot" ]; then
			kexeccmd="$kexeccmd -l $filepath"
			kexeccmd="$kexeccmd --command-line \"$restval\""
		else
			kexeccmd="$kexeccmd -l $filepath"
		fi
	fi
	if [ "$key" = "module" ]; then
		fix_file_path
		cmdline="$restval"
		if [ "$kexectype" = "xen" ]; then
			if [ "$module_number" -eq 1 ]; then
				adjust_cmd_line
			elif [ "$module_number" -eq 2 ]; then
				if [ "$printinitrd" = "y" ]; then
					# output the current path to initrd
					echo $filepath
				fi
				if [ -n "$override_initrd" ]; then
					filepath="$override_initrd"
				fi
			fi
		fi
		module_number=`expr $module_number + 1`
		kexeccmd="$kexeccmd --module \"$filepath $cmdline\""
	fi
	if [ "$key" = "initrd" ]; then
		fix_file_path
		if [ "$printinitrd" = "y" ]; then
			# output the current path to initrd
			echo $filepath
		fi
		if [ -n "$override_initrd" ]; then
			filepath="$override_initrd"
		fi
		kexeccmd="$kexeccmd --initrd=$filepath"
	fi
	if [ "$key" = "append" ]; then
		cmdline="$firstval $restval"
		adjust_cmd_line
		kexeccmd="$kexeccmd --append=\"$cmdline\""
	fi
done << EOF
$kexecparams
EOF

if [ "$adjusted_cmd_line" = "n" ]; then
	if [ "$kexectype" = "elf" ]; then
		kexeccmd="$kexeccmd --append=\"$cmdadd\""
	else
		die "Failed to add required kernel commands: $cmdadd"
	fi
fi

if [ "$dryrun" = "y" ]; then exit 0; fi

echo "Loading the new kernel:"
echo "$kexeccmd"
eval "$kexeccmd" \
|| die "Failed to load the new kernel"

echo "Starting the new kernel"
exec kexec -e
