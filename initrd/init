#!/bin/ash
mknod /dev/ttyprintk c 5 3
echo "hello world" > /dev/ttyprintk

# Setup our path
export PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin

# This is the very first script invoked by the Linux kernel and is
# running out of the ram disk.  There are no fileysstems mounted.
# It is important to have a way to invoke a recovery shell in case
# the boot scripts are messed up, but also important to modify the
# PCRs if this happens to prevent the TPM disk keys from being revealed.

# First thing it is vital to mount the /dev and other system directories
mkdir /proc /sys /dev /tmp /boot /media 2>&- 1>&-
mount /dev 2>/dev/ttyprintk
mount /proc 2>/dev/ttyprintk
mount /sys 2>/dev/ttyprintk

# Recovery shells will erase anything from here
mkdir -p /tmp/secret

# Load the date from the hardware clock, setting it in local time
hwclock -l -s

# Read the system configuration parameters
. /etc/functions
. /etc/config

# Configure linuxboot environment
if [ ! -z "$CONFIG_LINUXBOOT" ]; then
	mount /sys/firmware/efi/efivars
fi

if [ ! -z "$CONFIG_LINUX_PTY" ]; then
	# Setup the pty psudeo filesystem
	mkdir /dev/pts
	mount /dev/pts 2>/dev/ttyprintk

	if [ ! -r /dev/ptmx ]; then
		ln -s /dev/pts/ptmx /dev/ptmx
	fi
fi

# Setup recovery serial shell
if [ ! -z "$CONFIG_BOOT_RECOVERY_SERIAL" ]; then
	stty -F "$CONFIG_BOOT_RECOVERY_SERIAL" 115200
	/bin/sh < "$CONFIG_BOOT_RECOVERY_SERIAL" > "$CONFIG_BOOT_RECOVERY_SERIAL" 2>&1 &
fi

# Add our boot devices into the /etc/fstab, if they are defined
# in the configuration file.
if [ ! -z "$CONFIG_BOOT_DEV" ]; then
	echo >> /etc/fstab "$CONFIG_BOOT_DEV /boot auto defaults,ro 0 0"
fi
if [ ! -z "$CONFIG_USB_BOOT_DEV" ]; then
	echo >> /etc/fstab "$CONFIG_USB_BOOT_DEV /media auto defaults,ro 0 0"
fi

# Now it is safe to print a banner
if [ ! -z "$CONFIG_LINUXBOOT" ]; then
	MOTD=/etc/motd.nerf
else
	MOTD=/etc/motd.coreboot
fi
if [ -r "$MOTD" ]; then
	cat "$MOTD"
	if [ ! -z "$CONFIG_BOOT_RECOVERY_SERIAL" ]; then
		cat "$MOTD" > "$CONFIG_BOOT_RECOVERY_SERIAL"
	fi
fi

# Setup remote attestation interface
if [ ! -z "$CONFIG_BOOT_REMOTE" ]; then
	# bring up the ethernet; maybe should do DHCP?
	ifconfig lo 127.0.0.1

	if [ -f /lib/modules/e1000.ko ]; then
		insmod /lib/modules/e1000.ko
	fi
	if [ -f /lib/modules/e1000e.ko ]; then
		insmod /lib/modules/e1000e.ko
	fi

	if [ -e /sys/class/net/eth0 ]; then
		# Setup static IP
		if [ ! -z "$CONFIG_BOOT_REMOTE_STATIC_IP" ]; then
			ifconfig eth0 $CONFIG_BOOT_REMOTE_STATIC_IP
			ifconfig eth0 > /dev/ttyprintk
		fi
		# TODO: enable DHCP if configured

		# Setup the ssh server, allow root logins and log to stderr
		if [ ! -d /etc/dropbear ]; then
			mkdir /etc/dropbear
		fi
		dropbear -B -R 2>/dev/ttyprintk

		ifconfig eth0 | head -1 > "$CONFIG_BOOT_RECOVERY_SERIAL"
	fi
fi

# Setup local attestation interface
if [ ! -z "$CONFIG_BOOT_LOCAL" ]; then
	if [ ! -x "$CONFIG_BOOTSCRIPT" ]; then
		recovery 'Boot script missing?  Entering recovery shell'
		# just in case...
		if [ ! -z "$CONFIG_TPM" ]; then
			tpm extend -ix 4 -ic recovery
		fi
		exec /bin/ash
	fi

	# If the user has been holding down r, enter a recovery shell
	# otherwise immediately start the configured boot script.
	# We don't print a prompt, since this is a near instant timeout.
	read \
		-t 0.1 \
		-n 1 \
		boot_option
	echo

	if [ "$boot_option" = "r" ]; then
		# Start an interactive shell
		recovery 'User requested recovery shell'
		# just in case...
		if [ ! -z "$CONFIG_TPM" ]; then
			tpm extend -ix 4 -ic recovery
		fi
		exec /bin/ash
	fi

	echo '***** Normal boot:' $CONFIG_BOOTSCRIPT
	exec "$CONFIG_BOOTSCRIPT"
fi

recovery 'Entering recovery shell'
# belts and suspenders, just in case...
if [ ! -z "$CONFIG_TPM" ]; then
	tpm extend -ix 4 -ic recovery
fi
exec /bin/ash
