From c5acebb3c692330d3b3bda252bb045086f371675 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Micha=C5=82=20=C5=BBygowski?= <michal.zygowski@3mdeb.com>
Date: Sun, 10 Sep 2023 14:26:59 +0200
Subject: [PATCH 1/4] src/superio/nuvoton: Add HWM initialization code
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Michał Żygowski <michal.zygowski@3mdeb.com>
Change-Id: Ib78ad052204009dc1f9b90ad2272a83b304fd39d
---
 src/superio/nuvoton/nct6687d/Makefile.mk    |   5 +
 src/superio/nuvoton/nct6687d/chip.h         | 361 ++++++++
 src/superio/nuvoton/nct6687d/nct6687d_ec.c  |  77 ++
 src/superio/nuvoton/nct6687d/nct6687d_ec.h  |  27 +
 src/superio/nuvoton/nct6687d/nct6687d_hwm.c | 960 ++++++++++++++++++++
 src/superio/nuvoton/nct6687d/nct6687d_hwm.h | 922 +++++++++++++++++++
 src/superio/nuvoton/nct6687d/superio.c      |  10 +
 7 files changed, 2362 insertions(+)
 create mode 100644 src/superio/nuvoton/nct6687d/chip.h
 create mode 100644 src/superio/nuvoton/nct6687d/nct6687d_ec.c
 create mode 100644 src/superio/nuvoton/nct6687d/nct6687d_ec.h
 create mode 100644 src/superio/nuvoton/nct6687d/nct6687d_hwm.c
 create mode 100644 src/superio/nuvoton/nct6687d/nct6687d_hwm.h

diff --git a/src/superio/nuvoton/nct6687d/Makefile.mk b/src/superio/nuvoton/nct6687d/Makefile.mk
index d4785f726e..899cf5daec 100644
--- a/src/superio/nuvoton/nct6687d/Makefile.mk
+++ b/src/superio/nuvoton/nct6687d/Makefile.mk
@@ -1,3 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0-or-later
 
+bootblock-$(CONFIG_SUPERIO_NUVOTON_NCT6687D) += nct6687d_ec.c
+romstage-$(CONFIG_SUPERIO_NUVOTON_NCT6687D) += nct6687d_ec.c
+ramstage-$(CONFIG_SUPERIO_NUVOTON_NCT6687D) += nct6687d_ec.c
+
+ramstage-$(CONFIG_SUPERIO_NUVOTON_NCT6687D) += nct6687d_hwm.c
 ramstage-$(CONFIG_SUPERIO_NUVOTON_NCT6687D) += superio.c
diff --git a/src/superio/nuvoton/nct6687d/chip.h b/src/superio/nuvoton/nct6687d/chip.h
new file mode 100644
index 0000000000..edd0deb23a
--- /dev/null
+++ b/src/superio/nuvoton/nct6687d/chip.h
@@ -0,0 +1,361 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef SUPERIO_NUVOTON_NCT6687D_CHIP_H
+#define SUPERIO_NUVOTON_NCT6687D_CHIP_H
+
+#include <stdbool.h>
+
+#define MAX_TEMP_SPEED_LEVELS 7
+#define MAX_TEMP_SRC 4
+#define MAX_NUM_FANS 10
+#define MAX_NUM_SENSORS 32
+#define MAX_WEIGHT_POINTS 8
+#define MAX_DTS_CTL_POINTS 5
+
+enum nct6687d_sensor_src_select {
+	/* TIN sources */
+	SENSOR_DISABLE = 0x00,
+	SENSOR_LOCAL = 0x01,
+	TD0P_CURRENT_MODE = 0x02,
+	TD1P_CURRENT_MODE = 0x03,
+	TD2P_CURRENT_MODE = 0x04,
+	TD0P_VOLTAGE_MODE = 0x05,
+	TD1P_VOLTAGE_MODE = 0x06,
+	TD2P_VOLTAGE_MODE = 0x07,
+	THERMISTOR14 = 0x08,
+	THERMISTOR15 = 0x09,
+	THERMISTOR16 = 0x0A,
+	THERMISTOR0 = 0x0B,
+	THERMISTOR1 = 0x0C,
+	THERMISTOR2 = 0x0D,
+	THERMISTOR3 = 0x0E,
+	THERMISTOR4 = 0x0F,
+	THERMISTOR5 = 0x10,
+	THERMISTOR6 = 0x11,
+	THERMISTOR7 = 0x12,
+	THERMISTOR8 = 0x13,
+	THERMISTOR9 = 0x14,
+	THERMISTOR10 = 0x15,
+	THERMISTOR11 = 0x16,
+	THERMISTOR12 = 0x17,
+	THERMISTOR13 = 0x18,
+	PECI_AGENT0_DOMAIN0 = 0x20,
+	PECI_AGENT1_DOMAIN0 = 0x21,
+	PECI_AGENT2_DOMAIN0 = 0x22,
+	PECI_AGENT3_DOMAIN0 = 0x23,
+	PECI_AGENT0_DOMAIN1 = 0x24,
+	PECI_AGENT1_DOMAIN1 = 0x25,
+	PECI_AGENT2_DOMAIN1 = 0x26,
+	PECI_AGENT3_DOMAIN1 = 0x27,
+	PECI_DIMM_TMP0 = 0x28,
+	PECI_DIMM_TMP1 = 0x29,
+	PECI_DIMM_TMP2 = 0x2A,
+	PECI_DIMM_TMP3 = 0x2B,
+	PCH_CPU = 0x30,
+	PCH_CHIP = 0x31,
+	PCH_CHIP_CPU_MAX = 0x32,
+	PCH_MCH = 0x33,
+	PCH_DIMM0 = 0x34,
+	PCH_DIMM1 = 0x35,
+	PCH_DIMM2 = 0x36,
+	PCH_DIMM3 = 0x37,
+	SMBUS_THERMAL_SENSOR0 = 0x38,
+	SMBUS_THERMAL_SENSOR1 = 0x39,
+	SMBUS_THERMAL_SENSOR2 = 0x3A,
+	SMBUS_THERMAL_SENSOR3 = 0x3B,
+	SMBUS_THERMAL_SENSOR4 = 0x3C,
+	SMBUS_THERMAL_SENSOR5 = 0x3D,
+	DIMM_THERMAL_SENSOR0 = 0x3E,
+	DIMM_THERMAL_SENSOR1 = 0x3F,
+	DIMM_THERMAL_SENSOR2 = 0x40,
+	DIMM_THERMAL_SENSOR3 = 0x41,
+	AMD_TSI_ADDRESS_0x90 = 0x42,
+	AMD_TSI_ADDRESS_0x92 = 0x43,
+	AMD_TSI_ADDRESS_0x94 = 0x44,
+	AMD_TSI_ADDRESS_0x96 = 0x45,
+	AMD_TSI_ADDRESS_0x98 = 0x46,
+	AMD_TSI_ADDRESS_0x9A = 0x47,
+	AMD_TSI_ADDRESS_0x9C = 0x48,
+	AMD_TSI_ADDRESS_0x9D = 0x49,
+	VIRTUAL_TEMPIN0 = 0x50,
+	VIRTUAL_TEMPIN1 = 0x51,
+	VIRTUAL_TEMPIN2 = 0x52,
+	VIRTUAL_TEMPIN3 = 0x53,
+	VIRTUAL_TEMPIN4 = 0x54,
+	VIRTUAL_TEMPIN5 = 0x55,
+	VIRTUAL_TEMPIN6 = 0x56,
+	VIRTUAL_TEMPIN7= 0x57,
+	/* VIN soruces */
+	VCC= 0x60,
+	VSB= 0x61,
+	AVSB = 0x62,
+	VTT = 0x63,
+	VBAT = 0x64,
+	VREF = 0x65,
+	VIN0 = 0x66,
+	VIN1 = 0x67,
+	VIN2 = 0x68,
+	VIN3 = 0x69,
+	VIN4 = 0x6A,
+	VIN5 = 0x6B,
+	VIN6 = 0x6C,
+	VIN7 = 0x6D,
+	VIN8 = 0x6E,
+	VIN9 = 0x6F,
+	VIN10 = 0x70,
+	VIN11 = 0x71,
+	VIN12 = 0x72,
+	VIN13 = 0x73,
+	VIN14 = 0x74,
+	VIN15 = 0x75,
+	VIN16 = 0x76,
+};
+
+enum nct6687d_peci_speed {
+	PECI_2MHZ = 0,
+	PECI_1200KHZ,
+	PECI_800KHZ,
+	PECI_400KHZ,
+};
+
+enum nct6687d_baud_rate {
+	BAUD_12_5K = 0,
+	BAUD_25K,
+	BAUD_50K,
+	BAUD_100K,
+	BAUD_200K,
+	BAUD_400K,
+	BAUD_800K,
+	BAUD_1200K,
+};
+
+enum nct6687d_fan_mode {
+	FAN_IGNORE = 0,
+	FAN_THERMAL_CRUISE,
+	FAN_SPEED_CRUISE,
+	FAN_SMART_FAN_IV,
+	FAN_PID_CONTROL,
+	FAN_MODE_MANUAL,
+};
+
+enum nct6687d_tach_pwm_sel {
+	TACH_PWM0 = 0,
+	TACH_PWM1,
+	TACH_PWM2,
+	TACH_PWM3,
+	TACH_PWM4,
+	TACH_PWM5,
+	TACH_PWM6,
+	TACH_PWM7,
+	TACH_PWM8,
+	TACH_PWM9,
+	TACH_PWM10,
+	TACH_PWM11,
+	TACH_PWM12,
+	TACH_PWM13,
+	TACH_PWM14,
+	TACH_PWM15,
+	TACH_PWM16,
+	TACH_PWM17,
+	TACH_PWM18,
+	TACH_PWM19,
+	TACH_PWM20,
+	TACH_PWM21,
+	TACH_PWM22,
+	TACH_PWM23,
+};
+
+enum nct6687d_fan_unit_sel {
+	FAN_PWM = 0,
+	FAN_RPM,
+};
+
+enum nct6687d_fast_track_weight {
+	WEIGHT_DIV_1 = 0,
+	WEIGHT_DIV_2,
+	WEIGHT_DIV_4,
+	WEIGHT_DIV_8,
+	WEIGHT_DIV_16,
+	WEIGHT_DIV_32,
+	WEIGHT_DIV_64,
+};
+
+struct nct6687d_pch_smbus_sensor {
+	bool	sensor_en;
+	uint8_t	sensor_idx;
+	bool	report_one_byte;
+	uint8_t port_sel;
+	enum	nct6687d_baud_rate baud_rate;
+	uint8_t	sensor_addr;
+	uint8_t	sensor_cmd;
+};
+
+struct nct6687d_dts_sensor_config {
+	uint8_t ambient_temp[MAX_DTS_CTL_POINTS];
+	uint16_t rpm_start_point[MAX_DTS_CTL_POINTS];
+	uint16_t rpm_end_point[MAX_DTS_CTL_POINTS];
+	uint8_t	temp_start;
+	uint8_t	temp_end;
+	uint16_t max_speed;
+	bool peci_adjust;
+	uint8_t peci_agent_idx;
+};
+
+struct nct6687d_dts2_sensor_config {
+	int8_t	target_margin;
+	uint8_t	target_margin_tolerance;
+	int8_t	t_control;
+	int8_t	t_control_offset;
+	uint16_t step_speed;
+	uint16_t min_speed;
+	/* Unit is 1s */
+	uint8_t delay_time;
+	uint8_t divisor;
+};
+
+struct nct6687d_smart_fan_iv_config {
+	uint8_t temp_src[MAX_TEMP_SRC];
+	uint8_t temp_levels[MAX_TEMP_SPEED_LEVELS];
+	uint16_t speed_levels[MAX_TEMP_SPEED_LEVELS];
+	uint8_t temp_hystheresis;
+	uint8_t temp_cut_off;
+	uint8_t cut_off_delay;
+	/* Time in 100ms units */
+	uint8_t step_up_time;
+	uint8_t step_down_time;
+};
+
+struct nct6687d_manual_fan_config {
+	uint8_t manual_duty;
+};
+
+struct nct6687d_fan_thermal_cruise_config {
+	bool keep_min_fan_output;
+	uint8_t target_temp;
+	uint8_t temp_tolerance;
+	uint8_t initial_value;
+	uint8_t stop_value;
+	/* Time in 100ms units */
+	uint8_t stop_time;
+	uint8_t step_up_time;
+	uint8_t step_down_time;
+};
+
+struct nct6687d_fan_speed_cruise_config {
+	uint16_t target_rpm;
+	uint16_t rpm_tolerance;
+	/* Time in 100ms units */
+	uint8_t step_up_time;
+	uint8_t step_down_time;
+};
+
+struct nct6687d_ambient_floor_fan_config {
+	/* Units is RPM */
+	uint16_t minout_start;
+	uint16_t minout_end;
+	uint16_t minout_max;
+};
+
+struct nct6687d_ambient_floor_config {
+	uint8_t temp_start;
+	uint8_t temp_end;
+};
+
+struct nct6687d_smart_tracking_config {
+	uint8_t rpm_tolerance_low;
+	uint8_t rpm_tolerance_mid;
+	uint8_t rpm_tolerance_high;
+
+	uint16_t speed_boundary_low;
+	uint16_t speed_boundary_high;
+
+	/* Step tracking setting */
+	uint8_t step_up;
+	uint8_t step_down;
+
+	/* Fast tracking settings */
+	uint8_t temp_boundary;
+
+	enum nct6687d_fast_track_weight weight_up_low;
+	enum nct6687d_fast_track_weight weight_up_mid;
+	enum nct6687d_fast_track_weight weight_up_high;
+	enum nct6687d_fast_track_weight weight_down_low;
+	enum nct6687d_fast_track_weight weight_down_mid;
+	enum nct6687d_fast_track_weight weight_down_high;
+
+	uint8_t duty_step_low;
+	uint8_t duty_step_mid;
+	uint8_t duty_step_high;
+
+	/* Markup tracking setting */
+	uint8_t ambient_temp_boundary;
+	uint8_t weight_val;
+};
+
+
+struct nct6687d_fan_config {
+	enum nct6687d_fan_mode mode;
+	enum nct6687d_fan_unit_sel unit_sel;
+	enum nct6687d_tach_pwm_sel fanin_sel;
+	enum nct6687d_tach_pwm_sel fanout_sel;
+
+	struct nct6687d_smart_fan_iv_config smart_fan;
+	struct nct6687d_manual_fan_config manual_fan;
+	struct nct6687d_fan_thermal_cruise_config thermal_cruise_fan;
+	struct nct6687d_fan_speed_cruise_config speed_cruise_fan;
+
+	/* Fan ALG_FUNCTRL */
+	uint8_t fan_alg_weight;
+
+	uint8_t crit_temp;
+	uint8_t crit_temp_tolerance;
+
+	uint8_t temp_err_duty;
+
+	bool dts1_en;
+	bool dts2_en;
+	bool dts_ub_en;
+
+	/* Fan FUN_CTRL */
+	bool smart_tracking_en;
+	bool fast_tracking_en;
+	bool markup_tracking_en;
+
+	bool ambient_floor_en;
+	struct nct6687d_ambient_floor_fan_config amb_floor_fan_cfg;
+
+	uint8_t startup_duty;
+	uint8_t manual_offset;
+	uint8_t min_duty;
+};
+
+struct superio_nuvoton_nct6687d_config {
+	struct nct6687d_fan_config fans[MAX_NUM_FANS];
+	enum nct6687d_sensor_src_select sensors[MAX_NUM_SENSORS];
+
+	enum nct6687d_peci_speed peci_speed;
+
+	struct nct6687d_pch_smbus_sensor smbus_sensor;
+	struct nct6687d_dts_sensor_config dts_sensor;
+	struct nct6687d_dts2_sensor_config dts2_sensor;
+
+	struct nct6687d_ambient_floor_config ambient_floor;
+	struct nct6687d_smart_tracking_config smart_tracking;
+
+	uint8_t fan_default_val;
+};
+
+#define FAN1	fans[0]
+#define FAN2	fans[1]
+#define FAN3	fans[2]
+#define FAN4	fans[3]
+#define FAN5	fans[4]
+#define FAN6	fans[5]
+#define FAN7	fans[6]
+#define FAN8	fans[7]
+#define FAN9	fans[8]
+#define FAN10	fans[9]
+
+void nct6687d_hwm_init(uint16_t hwm_base, const struct superio_nuvoton_nct6687d_config *conf);
+
+#endif /* SUPERIO_NUVOTON_NCT6687D_CHIP_H */
diff --git a/src/superio/nuvoton/nct6687d/nct6687d_ec.c b/src/superio/nuvoton/nct6687d/nct6687d_ec.c
new file mode 100644
index 0000000000..0b25b164b4
--- /dev/null
+++ b/src/superio/nuvoton/nct6687d/nct6687d_ec.c
@@ -0,0 +1,77 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#include <arch/io.h>
+
+#include "nct6687d_ec.h"
+
+void nct6687d_ec_write_page(uint16_t iobase, uint8_t page, uint8_t index, uint8_t value)
+{
+	/* Need to write 0xff first to set the page */
+	outb(0xff, iobase + EC_PORT0_PAGE);
+	outb(page, iobase + EC_PORT0_PAGE);
+	outb(index, iobase + EC_PORT0_INDEX);
+	outb(value, iobase + EC_PORT0_DATA);
+	/* Need to write 0xff at the end of transaction */
+	outb(0xff, iobase + EC_PORT0_PAGE);
+}
+
+void nct6687d_ec_write_page_ff(uint16_t iobase, uint8_t page, uint8_t index, uint8_t value)
+{
+	/* Need to write 0xff first to set the page */
+	outb(0xff, iobase + EC_PORT0_PAGE);
+	outb(page, iobase + EC_PORT0_PAGE);
+	/* Extra 0xff to the index register */
+	outb(0xff, iobase + EC_PORT0_INDEX);
+	outb(index, iobase + EC_PORT0_INDEX);
+	outb(value, iobase + EC_PORT0_DATA);
+	/* Need to write 0xff at the end of transaction */
+	outb(0xff, iobase + EC_PORT0_PAGE);
+}
+
+void nct6687d_ec_and_or_page(uint16_t iobase, uint8_t page, uint8_t index,
+			     uint8_t and_mask, uint8_t or_mask)
+{
+	uint8_t val;
+	/* Need to write 0xff first to set the page */
+	outb(0xff, iobase + EC_PORT0_PAGE);
+	outb(page, iobase + EC_PORT0_PAGE);
+	outb(index, iobase + EC_PORT0_INDEX);
+	val = inb(iobase + EC_PORT0_DATA);
+	val &= and_mask;
+	val |= or_mask;
+	outb(val, iobase + EC_PORT0_DATA);
+	/* Need to write 0xff at the end of transaction */
+	outb(0xff, iobase + EC_PORT0_PAGE);
+}
+
+void nct6687d_ec_and_or_page_ff(uint16_t iobase, uint8_t page, uint8_t index,
+			     uint8_t and_mask, uint8_t or_mask)
+{
+	uint8_t val;
+	/* Need to write 0xff first to set the page */
+	outb(0xff, iobase + EC_PORT0_PAGE);
+	outb(page, iobase + EC_PORT0_PAGE);
+	/* Extra 0xff to the index register */
+	outb(0xff, iobase + EC_PORT0_INDEX);
+	outb(index, iobase + EC_PORT0_INDEX);
+	val = inb(iobase + EC_PORT0_DATA);
+	val &= and_mask;
+	val |= or_mask;
+	outb(val, iobase + EC_PORT0_DATA);
+	/* Need to write 0xff at the end of transaction */
+	outb(0xff, iobase + EC_PORT0_PAGE);
+}
+
+uint8_t nct6687d_ec_read_page(uint16_t iobase, uint8_t page, uint8_t index)
+{
+	uint8_t value;
+	/* Need to write 0xff first to set the page */
+	outb(0xff, iobase + EC_PORT0_PAGE);
+	outb(page, iobase + EC_PORT0_PAGE);
+	outb(index, iobase + EC_PORT0_INDEX);
+	value = inb(iobase + EC_PORT0_DATA);
+	/* Need to write 0xff at the end of transaction */
+	outb(0xff, iobase + EC_PORT0_PAGE);
+
+	return value;
+}
diff --git a/src/superio/nuvoton/nct6687d/nct6687d_ec.h b/src/superio/nuvoton/nct6687d/nct6687d_ec.h
new file mode 100644
index 0000000000..d32f32c467
--- /dev/null
+++ b/src/superio/nuvoton/nct6687d/nct6687d_ec.h
@@ -0,0 +1,27 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef SUPERIO_NUVOTON_NCT6687D_EC_H
+#define SUPERIO_NUVOTON_NCT6687D_EC_H
+
+#include <types.h>
+
+/* Offsets in the EC IO base. Port0 for firmware use, Port1 for software use */
+#define EC_PORT0_PAGE 0
+#define EC_PORT0_INDEX 1
+#define EC_PORT0_DATA 2
+#define EC_PORT0_HOST_IF_EVENT 3
+
+#define EC_PORT1_PAGE 4
+#define EC_PORT1_INDEX 5
+#define EC_PORT1_DATA 6
+#define EC_PORT1_HOST_IF_EVENT 7
+
+void nct6687d_ec_write_page(uint16_t iobase, uint8_t page, uint8_t index, uint8_t value);
+void nct6687d_ec_write_page_ff(uint16_t iobase, uint8_t page, uint8_t index, uint8_t value);
+void nct6687d_ec_and_or_page(uint16_t iobase, uint8_t page, uint8_t index,
+			     uint8_t and_mask, uint8_t or_mask);
+void nct6687d_ec_and_or_page_ff(uint16_t iobase, uint8_t page, uint8_t index,
+			     uint8_t and_mask, uint8_t or_mask);
+uint8_t nct6687d_ec_read_page(uint16_t iobase, uint8_t page, uint8_t index);
+
+#endif /* SUPERIO_NUVOTON_NCT6687D_EC_H */
diff --git a/src/superio/nuvoton/nct6687d/nct6687d_hwm.c b/src/superio/nuvoton/nct6687d/nct6687d_hwm.c
new file mode 100644
index 0000000000..262dd8a0e9
--- /dev/null
+++ b/src/superio/nuvoton/nct6687d/nct6687d_hwm.c
@@ -0,0 +1,960 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#include <console/console.h>
+#include <delay.h>
+
+#include "chip.h"
+#include "nct6687d_hwm.h"
+
+uint16_t nct6687d_hwm_base = 0;
+
+static bool check_cond(const bool cond, const char* error)
+{
+	if (!cond)
+		printk(BIOS_ERR, "NCT6687D: %s\n", error);
+
+	return !cond;
+}
+
+static inline void print_status_bit(const char* status, const bool cond)
+{
+	printk(BIOS_DEBUG, "\t%-45s: %s\n", status, cond ? "yes" : "no");
+}
+
+static void print_fan_engine_status(void)
+{
+	uint8_t fan_eng_sts = hwm_reg_read(FAN_ENGINE_STS_REG);
+
+	printk(BIOS_DEBUG, "NCT6687D: Fan Engine Status:\n");
+	print_status_bit("PECI configuration adjusted", fan_eng_sts & FAN_PECI_CFG_ADJUSTED);
+	print_status_bit("All enabled fan channels processed",
+			 fan_eng_sts & FAN_UNFINISHED_FLAG);
+	print_status_bit("Configuration phase", fan_eng_sts & FAN_CFG_PHASE);
+	print_status_bit("Configuration invalid", fan_eng_sts & FAN_CFG_INVALID);
+	print_status_bit("Configuration check done", fan_eng_sts & FAN_CFG_CHECK_DONE);
+	print_status_bit("Configuration locked", fan_eng_sts & FAN_CFG_LOCK);
+	printk(BIOS_DEBUG, "Fans in automatic mode driven by %s register\n",
+	       (fan_eng_sts & FAN_DRIVE_BY_DEFAULT_VAL) ? "DEFAULT_VAL" : "MOD_SEL");
+}
+
+static bool unlock_fan_register_set(void)
+{
+	uint8_t fan_eng_sts;
+	bool done = false;
+	unsigned int i;
+
+	fan_eng_sts = hwm_reg_read(FAN_ENGINE_STS_REG);
+
+	if (!(fan_eng_sts & FAN_CFG_LOCK) && (fan_eng_sts & FAN_CFG_PHASE))
+		return true;
+
+	for (i = 1000; i > 0; i--) {
+		/* Wait until EC exits config phase and config request is clear */
+		if ((hwm_reg_read(FAN_ENGINE_STS_REG) & FAN_CFG_PHASE) == 0 &&
+		    (hwm_reg_read(FAN_CFG_CTRL_REG) & FAN_CFG_REQUEST) == 0) {
+			done = true;
+			break;
+		}
+		mdelay(1);
+	}
+
+	if (!done) {
+		printk(BIOS_WARNING, "Timeout waiting for EC to exit config phase or clear"
+				     "config request\n");
+		print_fan_engine_status();
+		return false;
+	}
+
+	done = false;
+
+	hwm_reg_write(FAN_CFG_CTRL_REG, FAN_CFG_REQUEST);
+
+	for (i = 1000; i > 0; i--) {
+		/* Wait until EC unlock the register set */
+		if ((hwm_reg_read(FAN_ENGINE_STS_REG) & FAN_CFG_LOCK) == 0) {
+			done = true;
+			break;
+		}
+		mdelay(1);
+	}
+
+	if (!done) {
+		printk(BIOS_WARNING, "Timeout waiting for EC to unlock the fan registers\n");
+		print_fan_engine_status();
+		return false;
+	}
+
+	return true;
+}
+
+static void print_last_err(uint8_t error_code)
+{
+	uint8_t debug_level = BIOS_WARNING;
+	uint8_t last_err_code = hwm_reg_read(FAN_LAST_ERROR_CODE_REG);
+
+	if (last_err_code == FAN_NO_ERROR) {
+		printk(BIOS_DEBUG, "No error occurred.\n");
+		return;
+	}
+
+	/* Lower the debug level if it is an error we care about */
+	if (last_err_code == error_code)
+		debug_level = BIOS_ERR;
+
+	switch (last_err_code) {
+	case FAN_ERR_MODE_SELECT:
+		printk(debug_level, "Mode Select invalid configuration\n");
+		break;
+	case FAN_ERR_CRIT_TEMP_PROTECT:
+		printk(debug_level, "Critical Temperature Protection invalid configuration\n");
+		break;
+	case FAN_ERR_ITL_FAN_CONTROL:
+		printk(debug_level, "Intel DTS Sensor invalid configuration\n");
+		break;
+	case FAN_ERR_SMART_TRACKING:
+		printk(debug_level, "Smart Tracking invalid configuration\n");
+		break;
+	case FAN_ERR_THERMAL_CRUISE:
+		printk(debug_level, "Thermal Cruise invalid configuration\n");
+		break;
+	case FAN_ERR_SPEED_CRUISE:
+		printk(debug_level, "Speed Cruise invalid configuration\n");
+		break;
+	case FAN_ERR_SMART_FAN_IV:
+		printk(debug_level, "Smart Fan IV invalid configuration\n");
+		break;
+	case FAN_ERR_PID_CONTROL:
+		printk(debug_level, "PID control invalid configuration\n");
+		break;
+	default:
+		printk(debug_level, "Unkown fan configuration error %02x\n", last_err_code);
+		break;
+	}
+}
+
+static void lock_fan_register_set_and_check(uint8_t error_code)
+{
+	uint8_t fan_eng_sts;
+	bool done = false;
+	unsigned int i;
+
+	fan_eng_sts = hwm_reg_read(FAN_ENGINE_STS_REG);
+
+	if (fan_eng_sts & FAN_CFG_LOCK || !(fan_eng_sts & FAN_CFG_PHASE)) {
+		printk(BIOS_DEBUG, "Fan register set already locked or not in config phase\n");
+		return;
+	}
+
+	hwm_reg_write(FAN_CFG_CTRL_REG, FAN_CFG_DONE);
+
+	for (i = 1000; i > 0; i--) {
+		fan_eng_sts = hwm_reg_read(FAN_ENGINE_STS_REG);
+		/* Wait until EC checks the configuration */
+		if (fan_eng_sts & FAN_CFG_CHECK_DONE) {
+			done = true;
+			break;
+		}
+		mdelay(1);
+	}
+
+	if (!done) {
+		printk(BIOS_WARNING, "Timeout waiting for configuration check done\n");
+		print_fan_engine_status();
+		return;
+	}
+
+	fan_eng_sts = hwm_reg_read(FAN_ENGINE_STS_REG);
+
+	if (fan_eng_sts & FAN_CFG_INVALID) {
+		printk(BIOS_WARNING, "NCT6687D: Configuration error ocurred\n");
+		print_last_err(error_code);
+	}
+
+	if (!(fan_eng_sts & FAN_CFG_LOCK)) {
+		printk(BIOS_WARNING, "NCT6687D: Configuration registers did not lock\n");
+		print_fan_engine_status();
+	}
+}
+
+static void init_pch_smbus_sensor(const struct nct6687d_pch_smbus_sensor *smbus_sensor)
+{
+	if (!smbus_sensor->sensor_addr || !smbus_sensor->sensor_cmd) {
+		printk(BIOS_ERR, "NCT6687D SMBus sensor CMD or ADDR missing!\n");
+		return;
+	}
+
+	/* Enable SMBUS first */
+	hwm_reg_write(SMBUS_MASTER_CFG2_REG, 0x04);
+	hwm_reg_write(SMBUS_MASTER_BAUD_RATE_SEL_REG, SMB_MASTER_BAUD_100K);
+	hwm_reg_set_bits(SMBUS_MASTER_CFG1_REG, SMB_MASTER_EN);
+
+	hwm_reg_and_or(PCH_THERMAL_DATA_CFG_REG, ~PCH_BAUD_SEL_MASK,
+		       smbus_sensor->baud_rate & PCH_BAUD_SEL_MASK);
+	hwm_reg_and_or(PCH_THERMAL_DATA_CFG_REG, ~PCH_PORT_SEL_MASK,
+		       PCH_THERMAL_PORT(smbus_sensor->port_sel) & PCH_PORT_SEL_MASK);
+
+	if (smbus_sensor->report_one_byte)
+		hwm_reg_set_bits(PCH_THERMAL_DATA_CFG_REG, PCH_ONE_BYTE_REPORT);
+	else
+		hwm_reg_and_or(PCH_THERMAL_DATA_CFG_REG, ~PCH_ONE_BYTE_REPORT & 0xff, 0);
+
+
+	hwm_reg_write(PCH_DEVICE_ADDR_REG, smbus_sensor->sensor_addr);
+	hwm_reg_write(PCH_THERMAL_CMD_REG, smbus_sensor->sensor_cmd);
+}
+
+static void init_sensors(const struct superio_nuvoton_nct6687d_config *conf)
+{
+	unsigned int i;
+	bool peci_en = false;
+	const enum nct6687d_sensor_src_select *sensors = conf->sensors;
+
+	if (!unlock_fan_register_set()) {
+		printk(BIOS_ERR, "NCT6687D failed to unlock registers, "
+				 "skipping sensors programming\n");
+		return;
+	}
+
+	printk(BIOS_DEBUG, "NCT6687D programming sensors\n");
+	/* Start monitoring */
+	hwm_reg_set_bits(HWM_CONFIG_REG, HWM_EN);
+
+	for (i = 0; i < MAX_NUM_SENSORS; i++) {
+		hwm_reg_write(SENSOR_CFG_REG(i), sensors[i] & SENSOR_SRC_SEL_MASK);
+	
+		if (sensors[i] >= PECI_AGENT0_DOMAIN0 &&
+		    sensors[i] <= PECI_AGENT3_DOMAIN1) {
+			hwm_reg_and_or(PECI_AGENT_EN_REG, ~PECI_AGENT_EN_MASK,
+				       PECI_AGENT_EN(sensors[i] & 0x3));
+			peci_en = true;
+		}
+
+		/* Only PCH SMBus sensor supported right now */
+		if (sensors[i] >= PCH_CPU && sensors[i] <= PCH_DIMM3 &&
+		    i == conf->smbus_sensor.sensor_idx &&
+		    conf->smbus_sensor.sensor_en) {
+			init_pch_smbus_sensor(&conf->smbus_sensor);
+		}
+	}
+
+	if (peci_en) {
+		hwm_reg_and_or(PECI_CFG_REG, PECI_SPEED_SEL_MASK,
+			       conf->peci_speed & PECI_SPEED_SEL_MASK);
+		hwm_reg_set_bits(PECI_CFG_REG, PECI_AGENT_INIT | PECI_EN);
+	}
+
+	lock_fan_register_set_and_check(FAN_NO_ERROR);
+}
+
+static bool intel_dts_sensor_control_point_check(const struct nct6687d_dts_sensor_config *dts,
+						 unsigned int i)
+{
+	bool failure = false;
+
+	failure |= check_cond(dts->ambient_temp[i] <= 127,
+			      "DTS Sensor Ambient Temperature Levels should be <= 127");
+
+	if (i < MAX_DTS_CTL_POINTS - 1) {
+		failure |= check_cond(dts->ambient_temp[i + 1] >= dts->ambient_temp[i],
+				      "DTS Sensor next Ambient Temperature Level must be "
+				      "higher or equal to previous Ambient Temperature Level");
+		failure |= check_cond(dts->rpm_start_point[i + 1] >  dts->rpm_start_point[i],
+				      "DTS Sensor next RPM Start Point must be higher than "
+				      "previous RPM Start Point");
+		failure |= check_cond(dts->rpm_end_point[i + 1] >  dts->rpm_end_point[i],
+				      "DTS Sensor next RPM End Point must be higher than "
+				      "previous RPM End Point");
+	}
+
+	failure |= check_cond(dts->rpm_end_point[i] > dts->rpm_start_point[i],
+			      "DTS Sensor RPM End Point must be higher than corresponding RPM "
+			      "Start Point");
+
+	return failure;
+}
+
+static bool intel_dts_sensor_config_check(const struct nct6687d_dts_sensor_config *dts)
+{
+	bool failure = false;
+	unsigned int i;
+
+	failure |= check_cond(dts->temp_end > dts->temp_start,
+			      "DTS Sensor Temperture End Point should be > "
+			      "Temperture End Point");
+	failure |= check_cond(dts->temp_start <= 127,
+			      "DTS Sensor Temperture Start Point should be <= 127");
+	failure |= check_cond(dts->temp_end <= 127,
+			      "DTS Sensor Temperture End Point should be <= 127");
+	
+	if (dts->peci_adjust) {
+		failure |= check_cond(dts->peci_agent_idx < 8,
+				      "DTS Sensor PECI Agent Index should be < 8");
+	}
+
+	for (i = 0; i < MAX_DTS_CTL_POINTS; i++)
+		failure |= intel_dts_sensor_control_point_check(dts, i);
+
+	return failure;
+}
+
+static void init_intel_dts_sensor(const struct nct6687d_dts_sensor_config *dts)
+{
+	static int init_once = 0;
+	unsigned int i;
+
+	if (init_once)
+		return;
+
+	if (intel_dts_sensor_config_check(dts)) {
+		printk(BIOS_ERR, "NCT6687D DTS Sensor invalid config, "
+				 "skipping sensor programming\n");
+		return;
+	}
+
+	printk(BIOS_DEBUG, "NCT6687D programming DTS sensor\n");
+
+	hwm_reg_write(ITL_TEMP_START_POINT_REG, dts->temp_start);
+	hwm_reg_write(ITL_TEMP_END_POINT_REG, dts->temp_end);
+
+	hwm_reg_write(ITL_RPM_MAX_SPEED_HI_REG, dts->max_speed >> 8);
+	hwm_reg_write(ITL_RPM_MAX_SPEED_LO_REG, dts->max_speed & 0xff);
+
+	for (i = 0; i < MAX_DTS_CTL_POINTS; i++) {
+		hwm_reg_write(ITL_AMB_TEMP_START_POINT_REG(i), dts->ambient_temp[i]);
+		hwm_reg_write(ITL_RPM_START_POINT_HI_REG(i), dts->rpm_start_point[i] >> 8);
+		hwm_reg_write(ITL_RPM_START_POINT_LO_REG(i), dts->rpm_start_point[i] & 0xff);
+		hwm_reg_write(ITL_RPM_END_POINT_HI_REG(i), dts->rpm_end_point[i] >> 8);
+		hwm_reg_write(ITL_RPM_END_POINT_LO_REG(i), dts->rpm_end_point[i] & 0xff);
+	}
+
+	if (dts->peci_adjust) {
+		hwm_reg_and_or(ITL_DTS_CFG_REG, ~ITL_DTS_PECI_AGENT_IDX_SEL_MASK,
+			       dts->peci_agent_idx & ITL_DTS_PECI_AGENT_IDX_SEL_MASK);
+		hwm_reg_set_bits(ITL_DTS_CFG_REG, ITL_DTS_PECI_CFG_ADJUSTMENT);
+	}
+
+	init_once = 1;
+}
+
+static void init_intel_dts2_sensor(const struct nct6687d_dts2_sensor_config *dts2)
+{
+	static int init_once = 0;
+
+	if (init_once)
+		return;
+
+	printk(BIOS_DEBUG, "NCT6687D programming DTS2 sensor\n");
+
+	hwm_reg_write(DTS2_TARGET_MARGIN_REG, (uint8_t)dts2->target_margin);
+	hwm_reg_write(DTS2_TCONTROL_REG, (uint8_t)dts2->t_control);
+	hwm_reg_write(DTS2_TCONTROL_OFFSET_REG, (uint8_t)dts2->t_control_offset);
+	hwm_reg_write(DTS2_TARGET_TOLERANCE_REG, dts2->target_margin_tolerance);
+
+	hwm_reg_write(DTS2_STEP_SPEED_HI_REG, dts2->step_speed >> 8);
+	hwm_reg_write(DTS2_STEP_SPEED_LO_REG, dts2->step_speed & 0xff);
+	hwm_reg_write(DTS2_MIN_SPEED_HI_REG, dts2->min_speed >> 8);
+	hwm_reg_write(DTS2_MIN_SPEED_LO_REG, dts2->min_speed & 0xff);
+
+	hwm_reg_write(DTS2_DELAY_TIME_COUNTER_REG, dts2->delay_time);
+	hwm_reg_write(DTS2_DIVISOR_REG, dts2->divisor);
+
+	init_once = 1;
+}
+
+static void lock_sensor_config(void)
+{
+	if (!unlock_fan_register_set()) {
+		printk(BIOS_ERR, "NCT6687D failed to unlock registers, "
+				 "skipping misc fan config programming\n");
+		return;
+	}
+	hwm_reg_set_bits(HWM_CONFIG_REG, LOCK_SENSOR_CFG);
+	lock_fan_register_set_and_check(FAN_NO_ERROR);
+}
+
+static void init_ambient_floor_alg(const struct superio_nuvoton_nct6687d_config *conf,
+				   unsigned int idx)
+{
+	static int init_once = 0;
+	const struct nct6687d_ambient_floor_fan_config *amb_floor_fan;
+	const struct nct6687d_ambient_floor_config *amb_floor_cfg = &conf->ambient_floor;
+
+	amb_floor_fan = &conf->fans[idx - 1].amb_floor_fan_cfg;
+
+	printk(BIOS_DEBUG, "NCT6687D initializing ambient floor algorithm\n");
+
+	if (!init_once) {
+		hwm_reg_write(AMBIENT_FLOOR_TEMP_START_POINT_REG, amb_floor_cfg->temp_start);
+		hwm_reg_write(AMBIENT_FLOOR_TEMP_END_POINT_REG, amb_floor_cfg->temp_end);
+		init_once = 1;
+	}
+
+	hwm_reg_write(FAN_AMB_FLOOR_MIN_OUT_START_REG(idx),
+		      FAN_AMB_FLOOR_RPM_TO_REG(amb_floor_fan->minout_start));
+	hwm_reg_write(FAN_AMB_FLOOR_MIN_OUT_END_REG(idx),
+		      FAN_AMB_FLOOR_RPM_TO_REG(amb_floor_fan->minout_end));
+	hwm_reg_write(FAN_AMB_FLOOR_MAX_OUT_REG(idx),
+		      FAN_AMB_FLOOR_RPM_TO_REG(amb_floor_fan->minout_max));
+}
+
+static void init_smart_tracking_alg(const struct superio_nuvoton_nct6687d_config *conf,
+				    unsigned int idx)
+{
+	static int init_once = 0;
+	const struct nct6687d_fan_config *fan = &conf->fans[idx - 1];
+	const struct nct6687d_smart_tracking_config *smart_track = &conf->smart_tracking;
+
+	printk(BIOS_DEBUG, "NCT6687D initializing smart tracking algorithm\n");
+
+	if (!init_once) {
+		hwm_reg_write(FAN_LOW_RPM_SPEED_BOUNDARY_HI_REG,
+			      smart_track->speed_boundary_low >> 8);
+		hwm_reg_write(FAN_LOW_RPM_SPEED_BOUNDARY_LO_REG,
+			      smart_track->speed_boundary_low & 0xff);
+		hwm_reg_write(FAN_HIGH_RPM_SPEED_BOUNDARY_HI_REG,
+			      smart_track->speed_boundary_high >> 8);
+		hwm_reg_write(FAN_HIGH_RPM_SPEED_BOUNDARY_LO_REG,
+			      smart_track->speed_boundary_high & 0xff);
+		hwm_reg_write(FAN_LOW_RPM_TOLERANCE_REG, smart_track->rpm_tolerance_low);
+		hwm_reg_write(FAN_MID_RPM_TOLERANCE_REG, smart_track->rpm_tolerance_mid);
+		hwm_reg_write(FAN_HIGH_RPM_TOLERANCE_REG, smart_track->rpm_tolerance_high);
+
+		hwm_reg_write(FAN_TRACKING_STEP_REG, ((smart_track->step_up & 0xf) << 4) |
+						     (smart_track->step_down & 0xf));
+
+		hwm_reg_write(FAN_FAST_TRACK_TEMP_BOUNDARY_REG, smart_track->temp_boundary);
+
+		hwm_reg_write(FAN_LOW_RPM_FAST_TRACK_WEIGHT_REG,
+			      ((smart_track->weight_up_low & 7) << 4) |
+			      (smart_track->weight_down_low & 7));
+		hwm_reg_write(FAN_MID_RPM_FAST_TRACK_WEIGHT_REG,
+			      ((smart_track->weight_up_mid & 7) << 4) |
+			      (smart_track->weight_down_mid & 7));
+		hwm_reg_write(FAN_HIGH_RPM_FAST_TRACK_WEIGHT_REG,
+			      ((smart_track->weight_up_high & 7) << 4) |
+			      (smart_track->weight_down_high & 7));
+
+		hwm_reg_write(FAN_LOW_RPM_FAST_TRACK_DUTY_STEP_REG,
+			      smart_track->duty_step_low & 0xf);
+		hwm_reg_write(FAN_MID_RPM_FAST_TRACK_DUTY_STEP_REG,
+			      smart_track->duty_step_mid & 0xf);
+		hwm_reg_write(FAN_HIGH_RPM_FAST_TRACK_DUTY_STEP_REG,
+			      smart_track->duty_step_high & 0xf);
+
+		hwm_reg_write(FAN_MARKUP_TRACK_AMB_TEMP_BOUNDARY_REG,
+			      smart_track->ambient_temp_boundary);
+
+		hwm_reg_write(FAN_MARKUP_TRACK_WEIGHT_REG, smart_track->weight_val & 7);
+
+		init_once = 1;
+	}
+
+	if (fan->fast_tracking_en)
+		hwm_reg_set_bits(FAN_FUNCTION_CTRL(idx), FAN_FUN_FAST_TRACK_EN);
+
+
+	if (fan->markup_tracking_en)
+		hwm_reg_set_bits(FAN_FUNCTION_CTRL(idx), FAN_FUN_MARKUP_TRACK_EN);
+}
+
+static void misc_fan_config(const struct superio_nuvoton_nct6687d_config *conf,
+			    unsigned int idx)
+{
+	const struct nct6687d_fan_config *fan = &conf->fans[idx - 1];
+
+	if (!unlock_fan_register_set()) {
+		printk(BIOS_ERR, "NCT6687D failed to unlock registers, "
+				 "skipping misc fan config programming\n");
+		return;
+	}
+
+	if (fan->fan_alg_weight) {
+		printk(BIOS_DEBUG, "Programming algorithm weight for FAN%d\n", idx);
+		hwm_reg_and_or(FAN_ALG_ENGINE_WEIGHT_VAL_REG(idx),
+			       ~FAN_ALG_ENGINE_WEIGHT_MASK(idx),
+			       (fan->fan_alg_weight & 0xf) <<
+					FAN_ALG_ENGINE_WEIGHT_SHIFT(idx));
+		hwm_reg_set_bits(FAN_ALG_ENGINE_WEIGHT_EN_REG(idx),
+				 FAN_ALG_ENGINE_WEIGHT_CHANNEL_EN(idx));
+		hwm_reg_set_bits(FAN_ALG_FUNCTRL_REG(idx), FAN_ALG_FUNCTRL_ALG_EN);
+	}
+
+	if (fan->crit_temp) {
+		if (!check_cond(fan->crit_temp >= fan->crit_temp_tolerance,
+				"Fan Critical Temperature should be >= "
+				"Critical Temperature Tolerance")) {
+			printk(BIOS_DEBUG, "Enabling critical temperature for FAN%d\n", idx);
+			hwm_reg_write(FAN_CRIT_TEMP_CFG_REG(idx), fan->crit_temp & 0x7f);
+			if (fan->crit_temp_tolerance)
+				hwm_reg_write(FAN_CRIT_TEMP_TOLERANCE_REG(idx),
+					      fan->crit_temp_tolerance & 0xf);
+
+			hwm_reg_set_bits(FAN_ALG_FUNCTRL_REG(idx),
+					 FAN_ALG_FUNCTRL_CRIT_TEMP_EN);
+		}
+	}
+
+	if (fan->temp_err_duty) {
+		hwm_reg_write(FAN_TEMP_ERR_DUTY_VAL_REG(idx), fan->temp_err_duty);
+		hwm_reg_set_bits(FAN_ALG_FUNCTRL_REG(idx), FAN_ALG_FUNCTRL_TEMP_ERR);
+	}
+
+	if (fan->dts1_en && fan->dts2_en) {
+		printk(BIOS_ERR, "DTS and DTS2 sensors can't coexist!\n");
+		printk(BIOS_ERR, "Skipping DTS configuration\n");
+	} else {
+		if (fan->dts1_en) {
+			init_intel_dts_sensor(&conf->dts_sensor);
+			hwm_reg_set_bits(FAN_ALG_FUNCTRL_REG(idx), FAN_ALG_FUNCTRL_DTS1_EN);
+		}
+
+		if (fan->dts2_en) {
+			init_intel_dts2_sensor(&conf->dts2_sensor);
+			hwm_reg_set_bits(FAN_ALG_FUNCTRL_REG(idx), FAN_ALG_FUNCTRL_DTS2_EN);
+		}
+	}
+
+	if (fan->dts_ub_en)
+		hwm_reg_set_bits(FAN_ALG_FUNCTRL_REG(idx), FAN_ALG_FUNCTRL_DTS_UB_EN);
+
+
+	if (fan->smart_tracking_en) {
+		init_smart_tracking_alg(conf, idx);
+		hwm_reg_set_bits(FAN_FUNCTION_CTRL(idx), FAN_FUN_SMART_TRACK_EN);
+	}
+
+	if (conf->fan_default_val && conf->fan_default_val <= 100)
+		hwm_reg_write(FAN_DEFAULT_VAL_REG,
+			      FAN_PWM_PERCENT_TO_HEX(conf->fan_default_val));
+
+	/* Some registers for functionalities below are missing for fan 9 and 10 */
+	if (idx > 8) {
+		lock_fan_register_set_and_check(FAN_NO_ERROR);
+		return;
+	}
+
+	if (fan->ambient_floor_en) {
+		init_ambient_floor_alg(conf, idx);
+		hwm_reg_set_bits(FAN_FUNCTION_CTRL(idx), FAN_FUN_AMBIENT_FLOOR_EN);
+	}
+
+	if (fan->startup_duty && fan->startup_duty <= 100) {
+		hwm_reg_write(FAN_STARTUP_DUTY_REG(idx),
+			      FAN_PWM_PERCENT_TO_HEX(fan->startup_duty));
+		hwm_reg_set_bits(FAN_FUNCTION_CTRL(idx), FAN_FUN_STARTUP_EN);
+	}
+
+	if (fan->manual_offset) {
+		hwm_reg_write(FAN_MANUAL_OFFSET_REG(idx), fan->manual_offset);
+		hwm_reg_set_bits(FAN_FUNCTION_CTRL(idx), FAN_FUN_MANUAL_OFFSET_EN);
+	}
+
+	if (fan->min_duty && fan->min_duty <= 100) {
+		hwm_reg_write(FAN_MIN_DUTY_REG(idx), FAN_PWM_PERCENT_TO_HEX(fan->min_duty));
+		hwm_reg_set_bits(FAN_FUNCTION_CTRL(idx), FAN_FUN_MINDUTY_EN);
+	}
+
+	lock_fan_register_set_and_check(FAN_NO_ERROR);
+}
+
+static void set_fan_pins_and_mode(const struct nct6687d_fan_config *fan, unsigned int idx)
+{
+	enum nct6687d_fan_mode mode = fan->mode;
+
+	/* FAN_IGNORE takes the mapping of manual mode to detect unitialized fans */
+	if (mode == FAN_MODE_MANUAL)
+		mode = 0;
+
+	hwm_reg_and_or(FAN_MODE_SEL_REG(idx), ~FAN_MODE_SEL_MASK, mode & FAN_MODE_SEL_MASK);
+	hwm_reg_and_or(FANIN_CFG_REG(idx), ~FANIN_PIN_SEL_MASK,
+		       fan->fanin_sel & FANIN_PIN_SEL_MASK);
+	hwm_reg_set_bits(FANIN_CFG_REG(idx), FANIN_MONITOR_EN);
+
+	hwm_reg_and_or(FANOUT_CFG_REG(idx), ~FANOUT_PIN_SEL_MASK,
+		       fan->fanout_sel & FANOUT_PIN_SEL_MASK);
+	hwm_reg_set_bits(FANOUT_CFG_REG(idx), FANOUT_EN);
+}
+
+static bool smart_fan_level_check(const struct nct6687d_fan_config *fan,
+				  const struct nct6687d_smart_fan_iv_config *s_fan,
+				  int i)
+{
+	bool failure = false;
+
+	failure |= check_cond(s_fan->temp_levels[i] <= 127,
+			      "Smart Fan IV Temperature Levels should be <= 127");
+	if (i < MAX_TEMP_SPEED_LEVELS - 1) {
+		failure |= check_cond(s_fan->temp_levels[i + 1] >= s_fan->temp_levels[i],
+				      "Smart Fan IV next Temperature Level must be higher"
+				      " or equal to previous Temperature Level");
+		failure |= check_cond(s_fan->speed_levels[i + 1] >=  s_fan->speed_levels[i],
+				      "Smart Fan IV next Speed Level must be higher or "
+				      "equal to previous Speed Level");
+	}
+
+	if (fan->unit_sel == FAN_PWM) {
+		failure |= check_cond(s_fan->speed_levels[i] <= 100,
+				      "Smart Fan IV PWM Speed Levels should be <= 100");
+	} else if (fan->unit_sel == FAN_RPM) {
+		failure |= check_cond(s_fan->speed_levels[i] <= 0x3fff,
+				      "Smart Fan IV RPM Speed Levels should be"
+				      "<= 16383 RPM");
+	} else { 
+		failure |= check_cond(false, "Smart Fan IV invalid Fan Unit Selection");
+	}
+
+	return failure;
+
+}
+
+static bool smart_fan_config_check(const struct nct6687d_fan_config *fan,
+				   const struct nct6687d_smart_fan_iv_config *s_fan)
+{
+	bool failure = false;
+	unsigned int i;
+
+	for (i = 0; i < MAX_TEMP_SPEED_LEVELS; i++)
+		failure |= smart_fan_level_check(fan, s_fan, i);
+
+	failure |= check_cond(s_fan->temp_levels[0] >= s_fan->temp_cut_off,
+			      "Smart Fan IV Temperature Level 1 should be >= "
+			      "Temperature Cut Off");
+	failure |= check_cond(s_fan->temp_levels[0] >= 
+			      (s_fan->temp_cut_off + s_fan->temp_hystheresis),
+			      "Smart Fan IV Temperature Level 1 should be >= "
+			      "Temperature Cut Off + Temperature Hysteresis");
+
+	return failure;
+}
+
+static void init_smart_fan(const struct superio_nuvoton_nct6687d_config *conf, unsigned int idx)
+{
+	unsigned int i;
+	const struct nct6687d_fan_config *fan = &conf->fans[idx - 1];
+	const struct nct6687d_smart_fan_iv_config *sfan = &fan->smart_fan;
+
+	if (smart_fan_config_check(fan, sfan)) {
+		printk(BIOS_ERR, "NCT6687D Smart Fan IV invalid config, "
+				 "skipping fan programming\n");
+		return;
+	}
+
+	if (!unlock_fan_register_set()) {
+		printk(BIOS_ERR, "NCT6687D failed to unlock registers, "
+				 "skipping Smart Fan IV config programming\n");
+		return;
+	}
+
+	set_fan_pins_and_mode(fan, idx);
+
+	if (fan->unit_sel == FAN_PWM)
+		hwm_reg_and_or(FAN_FUNCTION_CTRL(idx), ~FAN_FUN_UNIT_RPM & 0xff,
+			       FAN_FUN_UNIT_PWM_DUTY);
+	else if (fan->unit_sel == FAN_RPM)
+		hwm_reg_set_bits(FAN_FUNCTION_CTRL(idx), FAN_FUN_UNIT_RPM);
+
+	/* Registers start from MSB */
+	for (i = 0; i < MAX_TEMP_SRC; i++) {
+		hwm_reg_write(FAN_MTZ_DCS_DATA_REG(MAX_TEMP_SRC - 1 - i, idx),
+			      sfan->temp_src[i]);
+	}
+
+	for (i = 0; i < MAX_TEMP_SPEED_LEVELS; i++) {
+		if (sfan->temp_levels[i])
+			hwm_reg_write(FAN_SF4_TEMP_LVL_REG(idx, i),
+				      sfan->temp_levels[i]);
+		if (sfan->speed_levels[i]) {
+			if (fan->unit_sel == FAN_PWM) {
+				hwm_reg_write(FAN_SF4_PWM_RPM_LVL_HI_REG(idx, i), 0);
+				hwm_reg_write(FAN_SF4_PWM_RPM_LVL_LO_REG(idx, i),
+					      FAN_PWM_PERCENT_TO_HEX(sfan->speed_levels[i]));
+			}
+
+			if (fan->unit_sel == FAN_RPM) {
+				hwm_reg_write(FAN_SF4_PWM_RPM_LVL_HI_REG(idx, i),
+					      sfan->speed_levels[i] >> 8);
+				hwm_reg_write(FAN_SF4_PWM_RPM_LVL_LO_REG(idx, i),
+					      sfan->speed_levels[i] & 0xff);
+			}
+		}
+	}
+
+	hwm_reg_write(FAN_SF4_TEMP_OFF_HYSTHERESIS_REG(idx), sfan->temp_hystheresis);
+	hwm_reg_write(FAN_SF4_TEMP_CUT_OFF_REG(idx), sfan->temp_cut_off);
+	hwm_reg_write(FAN_SF4_TEMP_OFF_DELAY_REG(idx), sfan->cut_off_delay);
+
+	hwm_reg_write(FAN_STEP_UP_TIME_REG(idx), sfan->step_up_time);
+	hwm_reg_write(FAN_STEP_DOWN_TIME_REG(idx), sfan->step_down_time);
+
+	/* Set fan mode to automatic */
+	hwm_reg_and_or(FAN_MANUAL_EN_REG(idx), ~FAN_MANUAL_EN(idx), 0x00);
+
+	hwm_reg_set_bits(FAN_CHANNEL_EN_REG(idx), FAN_CHANNEL_EN(idx));
+
+	lock_fan_register_set_and_check(FAN_ERR_SMART_FAN_IV);
+
+	misc_fan_config(conf, idx);
+}
+
+static void init_manual_fan(const struct superio_nuvoton_nct6687d_config *conf,
+			    unsigned int idx)
+{
+	const struct nct6687d_fan_config *fan = &conf->fans[idx - 1];
+	const struct nct6687d_manual_fan_config *manual_fan = &fan->manual_fan;
+
+	if (manual_fan->manual_duty || manual_fan->manual_duty > 100) {
+		printk(BIOS_ERR, "NCT6687D: invalid duty cycle for manual fan mode\n");
+		return;
+	}
+
+	if (!unlock_fan_register_set()) {
+		printk(BIOS_ERR, "NCT6687D failed to unlock registers, "
+				 "skipping manual fan config programming\n");
+		return;
+	}
+
+	set_fan_pins_and_mode(fan, idx);
+
+	if (fan->unit_sel == FAN_PWM)
+		hwm_reg_and_or(FAN_FUNCTION_CTRL(idx), ~FAN_FUN_UNIT_RPM & 0xff,
+			       FAN_FUN_UNIT_PWM_DUTY);
+	else if (fan->unit_sel == FAN_RPM)
+		hwm_reg_set_bits(FAN_FUNCTION_CTRL(idx), FAN_FUN_UNIT_RPM);
+
+	hwm_reg_write(FAN_MANUAL_VALUE_REG(idx),
+		      FAN_PWM_PERCENT_TO_HEX(manual_fan->manual_duty));
+
+	hwm_reg_set_bits(FAN_MANUAL_EN_REG(idx), FAN_MANUAL_EN(idx));
+
+	hwm_reg_set_bits(FAN_CHANNEL_EN_REG(idx), FAN_CHANNEL_EN(idx));
+
+	lock_fan_register_set_and_check(FAN_NO_ERROR);
+
+	misc_fan_config(conf, idx);
+}
+
+static bool thermal_cruise_config_check(const struct nct6687d_fan_thermal_cruise_config *tc_fan)
+{
+	bool failure = false;
+
+	failure |= check_cond(tc_fan->step_down_time > 0,
+			      "Thermal Cruise Step-Down Time should be > 0");
+	failure |= check_cond(tc_fan->step_up_time > 0,
+			      "Thermal Cruise Step-Up Time should be > 0");
+	failure |= check_cond(tc_fan->initial_value > tc_fan->stop_value,
+			      "Thermal Cruise Initial value should be > Stop Value");
+	failure |= check_cond(tc_fan->target_temp >= tc_fan->temp_tolerance,
+			      "Thermal Cruise Target Temperature should be"
+			      " >= Temperature Tolerance");
+	if (tc_fan->keep_min_fan_output) {
+		failure |= check_cond(tc_fan->stop_value > 0,
+				      "Thermal Cruise Stop Value should be > 0");
+	} else {
+		failure |= check_cond(tc_fan->stop_time > 0,
+				      "Thermal Cruise Stop Time should be > 0");
+	}
+
+	return failure;
+}
+
+static void init_thermal_cruise_fan(const struct superio_nuvoton_nct6687d_config *conf,
+				    unsigned int idx)
+{
+	const struct nct6687d_fan_config *fan = &conf->fans[idx - 1];
+	const struct nct6687d_fan_thermal_cruise_config *tc_fan = &fan->thermal_cruise_fan;
+
+	if (thermal_cruise_config_check(tc_fan)) {
+		printk(BIOS_ERR, "NCT6687D Thermal Cruise invalid config, "
+				 "skipping fan programming\n");
+		return;
+	}
+
+	if (!unlock_fan_register_set()) {
+		printk(BIOS_ERR, "NCT6687D failed to unlock registers, "
+				 "skipping Thermal Cruise fan config programming\n");
+		return;
+	}
+
+	set_fan_pins_and_mode(fan, idx);
+
+	hwm_reg_write(FAN_TC_TARGET_TEMP_REG(idx),
+		      tc_fan->target_temp & FAN_TC_TARGET_TEMP_MASK);
+
+	if (tc_fan->keep_min_fan_output) {
+		hwm_reg_set_bits(FAN_TC_TARGET_TEMP_REG(idx), FAN_TC_KEEP_MIN_OUTPUT);
+		hwm_reg_write(FAN_TC_STOP_VALUE_REG(idx), tc_fan->stop_value);
+	}
+
+	hwm_reg_write(FAN_TC_TARGET_TEMP_TOLERANCE_REG(idx),
+		      tc_fan->temp_tolerance & FAN_TC_TEMP_TOLERANCE_MASK);
+	
+	hwm_reg_write(FAN_INITIAL_VALUE_REG(idx), tc_fan->initial_value);
+
+	hwm_reg_write(FAN_TC_STOP_TIME_REG(idx), tc_fan->stop_time);
+	hwm_reg_write(FAN_TC_STEP_DOWN_TIME_REG(idx), tc_fan->step_up_time);
+	hwm_reg_write(FAN_TC_STEP_UP_TIME_REG(idx), tc_fan->step_down_time);
+
+	/* Set fan mode to automatic */
+	hwm_reg_and_or(FAN_MANUAL_EN_REG(idx), ~FAN_MANUAL_EN(idx), 0);
+
+	hwm_reg_set_bits(FAN_CHANNEL_EN_REG(idx), FAN_CHANNEL_EN(idx));
+
+	lock_fan_register_set_and_check(FAN_ERR_THERMAL_CRUISE);
+
+	misc_fan_config(conf, idx);
+}
+
+static bool speed_cruise_config_check(const struct nct6687d_fan_speed_cruise_config *sc_fan)
+{
+	bool failure = false;
+
+	failure |= check_cond(sc_fan->target_rpm <= 0x3fff,
+			      "Speed Cruise Target RPM should be <= 16838 RPM");
+	failure |= check_cond(sc_fan->target_rpm >= sc_fan->rpm_tolerance,
+			      "Speed Cruise Target RPM should be >= RPM Tolerance");
+	failure |= check_cond(sc_fan->step_down_time > 0,
+			      "Speed Cruise Step-Down Time should be > 0");
+	failure |= check_cond(sc_fan->step_up_time > 0,
+			      "Speed Cruise Step-Up Time should be > 0");
+
+	return failure;
+}
+
+static void init_speed_cruise_fan(const struct superio_nuvoton_nct6687d_config *conf,
+				  unsigned int idx)
+{
+	const struct nct6687d_fan_config *fan = &conf->fans[idx - 1];
+	const struct nct6687d_fan_speed_cruise_config *sc_fan = &fan->speed_cruise_fan;
+
+	if (speed_cruise_config_check(sc_fan)) {
+		printk(BIOS_ERR, "NCT6687D Speed Cruise invalid config, "
+				 "skipping fan programming\n");
+		return;
+	}
+
+	if (!unlock_fan_register_set()) {
+		printk(BIOS_ERR, "NCT6687D failed to unlock registers, "
+				 "skipping Speed Cruise fan config programming\n");
+		return;
+	}
+
+	set_fan_pins_and_mode(fan, idx);
+
+	/* Speed cruise should only enable RPM units */
+	hwm_reg_set_bits(FAN_FUNCTION_CTRL(idx), FAN_FUN_UNIT_RPM);
+
+	hwm_reg_write(FAN_SC_TARGET_RPM_HI_REG(idx), sc_fan->target_rpm >> 8);
+	hwm_reg_write(FAN_SC_TARGET_RPM_LO_REG(idx), sc_fan->target_rpm & 0xff);
+	
+	hwm_reg_write(FAN_SC_TARGET_RPM_TOLERANCE_HI_REG(idx), sc_fan->rpm_tolerance >> 8);
+	hwm_reg_write(FAN_SC_TARGET_RPM_TOLERANCE_LO_REG(idx), sc_fan->rpm_tolerance & 0xff);
+
+	hwm_reg_write(FAN_SC_STEP_DOWN_TIME_REG(idx), sc_fan->step_up_time);
+	hwm_reg_write(FAN_SC_STEP_UP_TIME_REG(idx), sc_fan->step_down_time);
+
+	/* Set fan mode to automatic */
+	hwm_reg_and_or(FAN_MANUAL_EN_REG(idx), ~FAN_MANUAL_EN(idx), 0x00);
+
+	hwm_reg_set_bits(FAN_CHANNEL_EN_REG(idx), FAN_CHANNEL_EN(idx));
+
+	lock_fan_register_set_and_check(FAN_ERR_SPEED_CRUISE);
+
+	misc_fan_config(conf, idx);
+};
+
+static void init_one_fan(const struct superio_nuvoton_nct6687d_config *conf, unsigned int idx)
+{
+	const struct nct6687d_fan_config *fan = &conf->fans[idx - 1];
+
+	switch(fan->mode) {
+	case FAN_THERMAL_CRUISE:
+		printk(BIOS_DEBUG, "Initializing Thermal Cruise for FAN%d\n", idx);
+		init_thermal_cruise_fan(conf, idx);
+		break;
+	case FAN_SPEED_CRUISE:
+		printk(BIOS_DEBUG, "Initializing Speed Cruise for FAN%d\n", idx);
+		init_speed_cruise_fan(conf, idx);
+		break;
+	case FAN_SMART_FAN_IV:
+		printk(BIOS_DEBUG, "Initializing Smart FAN IV for FAN%d\n", idx);
+		init_smart_fan(conf, idx);
+		break;
+	case FAN_PID_CONTROL:
+		printk(BIOS_WARNING, "NCT6687D: PID Control fan mode not yet supported\n");
+		break;
+	case FAN_MODE_MANUAL:
+		printk(BIOS_DEBUG, "Initializing manual fan mode for FAN%d\n", idx);
+		init_manual_fan(conf, idx);
+		break;
+	default:
+		printk(BIOS_ERR, "NCT6687D: unknown fan mode detected!\n");
+	}
+}
+
+static void init_fans(const struct superio_nuvoton_nct6687d_config *conf)
+{
+	unsigned int i;
+	const struct nct6687d_fan_config *fans = conf->fans;
+
+	for (i = 1; i <= MAX_NUM_FANS; i++) {
+		if (fans[i - 1].mode == FAN_IGNORE)
+			continue;
+
+		init_one_fan(conf, i);
+	}
+}
+
+static void report_ec_info(void)
+{
+	unsigned int i;
+
+	printk(BIOS_DEBUG, "NCT6687D EC info:\n");
+	printk(BIOS_DEBUG, "\tChip ID: %04x\n", 
+	       (uint16_t)hwm_reg_read(CHIP_ID0_REG) |
+	       (uint16_t)(hwm_reg_read(CHIP_ID1_REG) << 8));
+	printk(BIOS_DEBUG, "\tCustomer ID: %04x\n",
+	       (uint16_t)hwm_reg_read(CUSTOMER_ID0_REG) |
+	       (uint16_t)(hwm_reg_read(CUSTOMER_ID1_REG) << 8));
+	printk(BIOS_DEBUG, "\tFW build date: %02d/%02d/20%02d\n",
+	       hwm_reg_read(FW_BUILD_DAY_REG),
+	       hwm_reg_read(FW_BUILD_MONTH_REG),
+	       hwm_reg_read(FW_BUILD_YEAR_REG));
+	printk(BIOS_DEBUG, "\tFW build serial number: %d\n",
+	       hwm_reg_read(FW_BUILD_SERIALNUM_REG));
+	printk(BIOS_DEBUG, "\tFW version: %d.%d\n",
+	       hwm_reg_read(FW_VER0_REG),
+	       hwm_reg_read(FW_VER1_REG));
+	printk(BIOS_DEBUG, "\tProfile version: %d\n",
+	       hwm_reg_read(PROFILE_VER_REG));
+	printk(BIOS_DEBUG, "\tROM version: %d.%d.%d.%d\n",
+	       hwm_reg_read(ROM_VER0_REG), hwm_reg_read(ROM_VER1_REG),
+	       hwm_reg_read(ROM_VER2_REG), hwm_reg_read(ROM_VER3_REG));
+	printk(BIOS_DEBUG, "\tISP build date: %02d/%02d/20%02d\n",
+	       hwm_reg_read(ISP_BUILD_DAY_REG),
+	       hwm_reg_read(ISP_BUILD_MONTH_REG),
+	       hwm_reg_read(ISP_BUILD_YEAR_REG));
+	printk(BIOS_DEBUG, "\tISP build serial number: %d\n",
+	       hwm_reg_read(ISP_BUILD_SERIALNUM_REG));
+	printk(BIOS_DEBUG, "\tISP version: %d.%d\n",
+	       hwm_reg_read(ISP_VER0_REG),
+	       hwm_reg_read(ISP_VER1_REG));
+	printk(BIOS_DEBUG, "\tOEM version:");
+
+	for (i = 0; i < OEM_VER_LEN; i++)
+		printk(BIOS_DEBUG, "%02x", hwm_reg_read(OEM_VER_REG + i));
+
+	printk(BIOS_DEBUG, "\n");
+}
+
+void nct6687d_hwm_init(uint16_t hwm_base, const struct superio_nuvoton_nct6687d_config *conf)
+{
+	nct6687d_hwm_base = hwm_base;
+
+	report_ec_info();
+
+	init_sensors(conf);
+	init_fans(conf);
+
+	lock_sensor_config();
+	print_fan_engine_status();
+}
diff --git a/src/superio/nuvoton/nct6687d/nct6687d_hwm.h b/src/superio/nuvoton/nct6687d/nct6687d_hwm.h
new file mode 100644
index 0000000000..0a7b83b7e3
--- /dev/null
+++ b/src/superio/nuvoton/nct6687d/nct6687d_hwm.h
@@ -0,0 +1,922 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+
+#ifndef SUPERIO_NUVOTON_NCT6687D_HWM_H
+#define SUPERIO_NUVOTON_NCT6687D_HWM_H
+
+#include <assert.h>
+#include <types.h>
+
+#include "chip.h"
+#include "nct6687d_ec.h"
+
+/*
+ * EC page number will be concatenated with the register offset to mark
+ * which page the register belongs to.
+ */
+#define EC_PAGE(page)				((page) << 8)
+#define EC_PAGE_REG(page, reg)			(EC_PAGE(page) + (reg))
+
+/* EC page 1 */
+#define SENSOR_READ_HI_REG(x)			EC_PAGE_REG(1, 0x00 + 2*(x))
+#define SENSOR_READ_LO_REG(x)			EC_PAGE_REG(1, 0x01 + 2*(x))
+#define FAN_RPM_READ_HI_REG(x)			EC_PAGE_REG(1, 0x40 + 2*((x) - 1))
+#define FAN_RPM_READ_LO_REG(x)			EC_PAGE_REG(1, 0x41 + 2*((x) - 1))
+
+#define FAN_DUTY_REG(fan) \
+	(((fan) > 8)	? EC_PAGE_REG(8, 0xf0 + ((fan)-8)) \
+			: EC_PAGE_REG(1, 0x60 + 2*((fan) - 1)))
+
+#define SENSOR_MON_STS_REG			EC_PAGE_REG(1, 0x70)
+#define   TEMP_OVERLOAD				(1 << 1)
+#define   VOLT_OVERLOAD				(1 << 1)
+#define   FAN_OVERLOAD				(1 << 2)
+
+/* Errors and statuses */
+#define PROCHOT_MON_STS_REG			EC_PAGE_REG(1, 0x71)
+#define SENSOR_ERROR_STS_REG(x)			EC_PAGE_REG(1, 0x74 + (x))
+#define TMPIN_IDLE_STS_REG(x)			EC_PAGE_REG(1, 0x78 + (x))
+#define FANIN_ERROR_STS_REG(x)			EC_PAGE_REG(1, 0x7C + (x))
+#define FANOUT_ERROR_STS_REG			EC_PAGE_REG(1, 0x7e)
+#define FAN_INIT_STS_REG			EC_PAGE_REG(1, 0x7f)
+
+#define HWM_CONFIG_REG				EC_PAGE_REG(1, 0x80)
+#define   SMI_SCI_SEL				(1 << 2)
+#define   LOCK_SENSOR_CFG			(1 << 5)
+#define   HWM_EN				(1 << 7)
+
+#define SENSOR_MON_VCC_DELAY_REG		EC_PAGE_REG(1, 0x81)
+#define TEMPIN_IDLE_COUNTER_REG			EC_PAGE_REG(1, 0x82)
+#define VIRTUAL_INPUT_CFG_REG			EC_PAGE_REG(1, 0x83)
+#define TMPIN_POLLING_RATE_REG			EC_PAGE_REG(1, 0x85)
+#define VIN_POLLING_RATE_REG			EC_PAGE_REG(1, 0x86)
+#define FAN_POLLING_RATE_REG			EC_PAGE_REG(1, 0x87)
+
+#define ADC_CLOCKK_DIV_REG			EC_PAGE_REG(1, 0x88)
+#define ADC_AVG_NUM_REG				EC_PAGE_REG(1, 0x89)
+#define ADC_SLOPE_HI_REG			EC_PAGE_REG(1, 0x8a)
+#define ADC_SLOPE_LO_REG			EC_PAGE_REG(1, 0x8b)
+
+#define PROCHOT_CFG_REG				EC_PAGE_REG(1, 0x8e)
+#define   REFRESH_RATE_MASK			(3 << 0)
+#define     REFRESH_RATE_100MS			(0 << 0)
+#define     REFRESH_RATE_200MS			(1 << 0)
+#define     REFRESH_RATE_500MS			(2 << 0)
+#define     REFRESH_RATE_1S			(3 << 0)
+#define   AVG_TIME_MASK				(3 << 2)
+#define     AVG_TIME_1				(0 << 2)
+#define     AVG_TIME_2				(1 << 2)
+#define     AVG_TIME_4				(2 << 2)
+#define     AVG_TIME_8				(3 << 2)
+#define   MONITOR_MODE_MASK			(3 << 4)
+#define     MONITOR_MODE_CAPTURE		(0 << 4)
+#define     MONITOR_MODE_8BIT			(1 << 4)
+#define     MONITOR_MODE_12BIT			(2 << 4)
+#define     MONITOR_MODE_16BIT			(3 << 4)
+#define   CLK_SRC_40K				(0 << 6)
+#define   CLK_SRC_MCLK				(1 << 6)
+#define   PROCHOT_EN				(1 << 7)
+
+#define PROCHOT_OUT_REG				EC_PAGE_REG(1, 0x8f)
+
+#define VIRTUAL_SENSOR_INPUT_REG(x)		EC_PAGE_REG(1, 0x90 + (x))
+
+#define SENSOR_CFG_REG(x)			EC_PAGE_REG(1, 0xa0 + (x))
+#define  FILTER_EN				(1 << 7)
+#define  SENSOR_SRC_SEL_MASK			0x7f
+
+#define FANIN_CFG_REG(fan)			EC_PAGE_REG(1, 0xc0 + ((fan) - 1))
+#define   FANIN_PIN_SEL_MASK			0x1f
+#define   FANIN_PULSE_REV_MASK			(3 << 5)
+#define   FANIN_PULSE_REV_SHIFT			5
+#define   FANIN_MONITOR_EN			(1 << 7)
+
+#define FANOUT_CFG_REG(fan) \
+	(((fan) > 8)	? EC_PAGE_REG(8, 0xf4 + ((fan) - 9)) \
+			: EC_PAGE_REG(1, 0xd0 + ((fan) - 1)))
+#define   FANOUT_PIN_SEL_MASK			0x1f
+#define   FANOUT_TYPE_PP			(0 << 5)
+#define   FANOUT_TYPE_OD			(1 << 5)
+#define   FANOUT_INV_EN				(1 << 6)
+#define   FANOUT_EN				(1 << 7)
+
+#define FAN_INIT_RPM_HI_REG(fan)		EC_PAGE_REG(1, 0xe0 + 2*((fan) - 1))
+#define FAN_INIT_RPM_LO_REG(fan)		EC_PAGE_REG(1, 0xe1 + 2*((fan) - 1))
+#define FAN_INIT_DUTY_VAL_REG(fan)		EC_PAGE_REG(1, 0xf0 + ((fan) - 1))
+#define FAN_INIT_MODE_REG			EC_PAGE_REG(1, 0xf8)
+#define   FAN_INIT_MODE_RPM(fan)		(1 << ((fan) - 1))
+#define   FAN_INIT_MODE_PWM(fan)		(0 << ((fan) - 1))
+
+#define FAN_RPM_INIT_UNIT_REG			EC_PAGE_REG(1, 0xf9)
+#define FAN_RPM_INIT_TOLERANCE_REG		EC_PAGE_REG(1, 0xfa)
+#define FAN_RPM_INIT_STABLE_COUNTER_REG		EC_PAGE_REG(1, 0xfb)
+#define FAN_RPM_INIT_TIME_COUNTER_REG		EC_PAGE_REG(1, 0xfc)
+
+/* EC Page 2 - GPIO */
+
+#define TIN_OFFSET_REG(x)			EC_PAGE_REG(2, 0x00 + (x))
+
+#define GPI_FALLING_TRIG_EN_HI_REG		EC_PAGE_REG(2, 0xb0)
+#define GPI_FALLING_TRIG_EN_LO_REG		EC_PAGE_REG(2, 0xb1)
+#define GPI_RISING_TRIG_EN_HI_REG		EC_PAGE_REG(2, 0xb2)
+#define GPI_RISING_TRIG_EN_LO_REG		EC_PAGE_REG(2, 0xb3)
+#define GPI_DATA_HI_REG				EC_PAGE_REG(2, 0xb4)
+#define GPI_DATA_LO_REG				EC_PAGE_REG(2, 0xb5)
+#define GPI_SEL_REG(x)				EC_PAGE_REG(2, 0xc0 + (x))
+#define GPO_TYPE_HI_REG				EC_PAGE_REG(2, 0xd0)
+#define GPO_TYPE_LO_REG				EC_PAGE_REG(2, 0xd1)
+#define GPO_DATA_HI_REG				EC_PAGE_REG(2, 0xd4)
+#define GPO_DATA_LO_REG				EC_PAGE_REG(2, 0xd5)
+#define GPO_SEL_REG(x)				EC_PAGE_REG(2, 0xe0 + (x))
+
+/* EC page 3 */
+
+#define SENSOR_INT_CFG_REG(x)			EC_PAGE_REG(3, 0x10 + (x))
+#define   TMPIN_INT_SEL_MASK			(7 << 0)
+#define   TMPIN_INT_DISABLE			(0 << 0)
+#define   TMPIN_INT_SHUTDOWN_MODE		(1 << 0)
+#define   TMPIN_INT_SYST_FAN_COMP_MODE		(2 << 0)
+#define   TMPIN_INT_CPUT_FAN_COMP_MODE		(3 << 0)
+#define   TMPIN_INT_TWO_TIMES_MODE		(4 << 0)
+#define   TMPIN_INT_ONE_TIME_MODE		(5 << 0)
+#define   TMPIN_INT_OVT_COMP_MODE		(6 << 0)
+#define   TMPIN_INT_OVT_MODE			(7 << 0)
+#define   VIN_INT_EN				(1 << 7)
+
+#define TMPIN_HYSTERSIS_REG(x)			EC_PAGE_REG(3, 0x30 + (x))
+#define TMPIN_OVERTEMP_REG(x)			EC_PAGE_REG(3, 0x50 + (x))
+#define TIN_SHUTDOWN_VIN_LIMIT_HI_REG(x)	EC_PAGE_REG(3, 0x70 + 2*(x))
+#define TIN_SHUTDOWN_VIN_LIMIT_LO_REG(x)	EC_PAGE_REG(3, 0x71 + 2*(x))
+
+#define FAN_RPM_INT_EN1_REG			EC_PAGE_REG(3, 0xb0)
+#define FAN_RPM_INT_EN2_REG			EC_PAGE_REG(3, 0xb1)
+
+#define FAN_RPM_LIMIT_HI_REG(fan)		EC_PAGE_REG(3, 0xb8 + 2*(fan))
+#define FAN_RPM_LIMIT_LO_REG(fan)		EC_PAGE_REG(3, 0xb9 + 2*(fan))
+
+/* EC Page 4 - SMBus */
+
+#define PCH_ERR_STS_REG				EC_PAGE_REG(4, 0x00)
+#define TSI_ERR_STS_REG				EC_PAGE_REG(4, 0x01)
+#define SMBUS_MASTER_ERR_STS_REG		EC_PAGE_REG(4, 0x04)
+#define SMBUS_THERM_SENSOR_ERR_STS_REG(x)	EC_PAGE_REG(4, 0x06 + (x))
+#define SMBUS_DIMM_SENSOR_ERR_STS_REG(x)	EC_PAGE_REG(4, 0x0c + (x))
+
+#define PCH_THERMAL_DATA_CFG_REG		EC_PAGE_REG(4, 0x10)
+#define   PCH_BAUD_SEL_MASK			(7 << 0)
+#define      PCH_BAUD_12_5K			(0  << 0)
+#define      PCH_BAUD_25K			(1  << 0)
+#define      PCH_BAUD_50K			(2  << 0)
+#define      PCH_BAUD_100K			(3  << 0)
+#define      PCH_BAUD_200K			(4  << 0)
+#define      PCH_BAUD_400K			(5  << 0)
+#define      PCH_BAUD_800K			(6  << 0)
+#define      PCH_BAUD_1200K			(7  << 0)
+#define   PCH_PORT_SEL_MASK			(3 << 4)
+#define     PCH_THERMAL_PORT(x)			((x) << 4)
+#define   PCH_ONE_BYTE_REPORT			(1 << 7)
+
+#define PCH_DEVICE_ADDR_REG			EC_PAGE_REG(4, 0x11)
+#define PCH_THERMAL_CMD_REG			EC_PAGE_REG(4, 0x12)
+
+#define TSI_THERMAL_DATA_CFG_REG		EC_PAGE_REG(4, 0x14)
+#define   TSI_BAUD_SEL_MASK			(7 << 0)
+#define      TSI_BAUD_12_5K			(0  << 0)
+#define      TSI_BAUD_25K			(1  << 0)
+#define      TSI_BAUD_50K			(2  << 0)
+#define      TSI_BAUD_100K			(3  << 0)
+#define      TSI_BAUD_200K			(4  << 0)
+#define      TSI_BAUD_400K			(5  << 0)
+#define      TSI_BAUD_800K			(6  << 0)
+#define      TSI_BAUD_1200K			(7  << 0)
+#define   TSI_PORT_SEL_MASK			(3 << 4)
+#define     TSI_THERMAL_PORT(x)			((x) << 4)
+
+#define SMBUS_SENSOR_CFG_REG(x)			EC_PAGE_REG(4, 0x1a + 5*(x))
+#define   SMB_BAUD_SEL_MASK			(7 << 0)
+#define      SMB_BAUD_12_5K			(0  << 0)
+#define      SMB_BAUD_25K			(1  << 0)
+#define      SMB_BAUD_50K			(2  << 0)
+#define      SMB_BAUD_100K			(3  << 0)
+#define      SMB_BAUD_200K			(4  << 0)
+#define      SMB_BAUD_400K			(5  << 0)
+#define      SMB_BAUD_800K			(6  << 0)
+#define      SMB_BAUD_1200K			(7  << 0)
+#define   SMB_PORT_SEL_MASK			(3 << 4)
+#define     SMB_SENSOR_PORT(x)			((x) << 4)
+#define   SMB_SENSOR_DATA_LEN_1B		(0 << 6)
+#define   SMB_SENSOR_DATA_LEN_2B		(1 << 6)
+#define   SMB_SENSOR_DIRECT_ACCESS		(1 << 7)
+
+#define SMBUS_SENSOR_ADDR_REG(x)		EC_PAGE_REG(4, 0x1b + 5*(x))
+#define SMBUS_SENSOR_CMD_REG(x)			EC_PAGE_REG(4, 0x1c + 5*(x))
+#define SMBUS_SENSOR_DATA_REG(x)		EC_PAGE_REG(4, 0x1d + 5*(x))
+#define SMBUS_SENSOR_READ_CMD_REG(x)		EC_PAGE_REG(4, 0x1e + 5*(x))
+
+#define SMBUS_DIMM_SENSOR_CFG0(x)		EC_PAGE_REG(4, 0x3a + 4*(x))
+#define   SMB_DIMM_ADDR_MASK			0x07
+#define   SMB_DIMM_BAUD_SEL_MASK		(7 << 4)
+#define      SMB_DIMM_BAUD_12_5K		(0  << 0)
+#define      SMB_DIMM_BAUD_25K			(1  << 0)
+#define      SMB_DIMM_BAUD_50K			(2  << 0)
+#define      SMB_DIMM_BAUD_100K			(3  << 0)
+#define      SMB_DIMM_BAUD_200K			(4  << 0)
+#define      SMB_DIMM_BAUD_400K			(5  << 0)
+#define      SMB_DIMM_BAUD_800K			(6  << 0)
+#define      SMB_DIMM_BAUD_1200K		(7  << 0)
+#define   SMBUS_DIMM_SENSOR_EN			(1 << 7)
+
+#define SMBUS_DIMM_SENSOR_CFG1_REG(x)		EC_PAGE_REG(4, 0x3b + 4*(x))
+/* Bits 0-2 is address as in CFG0, bit 7 is DIMM sensor enable */
+#define   SMD_DIMM_ADDR_MASK			0x07
+#define   SMB_PORT_SEL_MASK			(3 << 4)
+#define     SMB_SENSOR_PORT(x)			((x) << 4)
+
+#define SMBUS_DIMM_SENSOR_CFG2_REG(x)		EC_PAGE_REG(4, 0x3c + 4*(x))
+/* Bits 0-2 is address as in CFG0, bit 7 is DIMM sensor enable */
+
+#define SMBUS_DIMM_SENSOR_CFG3_REG(x)		EC_PAGE_REG(4, 0x3d + 4*(x))
+/* Bits 0-2 is address as in CFG0, bit 7 is DIMM sensor enable */
+
+#define SMBUS_MASTER_CFG1_REG			EC_PAGE_REG(4, 0x60)
+#define   SMB_MASTER_POLLRATE_MASK		0x07
+#define     SMB_MASTER_POLLRATE_ONCE		(0 << 0)
+#define     SMB_MASTER_POLLRATE_100MS		(0 << 0)
+#define     SMB_MASTER_POLLRATE_200MS		(0 << 0)
+#define     SMB_MASTER_POLLRATE_400MS		(0 << 0)
+#define     SMB_MASTER_POLLRATE_800MS		(0 << 0)
+#define     SMB_MASTER_POLLRATE_1S		(0 << 0)
+#define     SMB_MASTER_POLLRATE_2S		(0 << 0)
+#define     SMB_MASTER_POLLRATE_4S		(0 << 0)
+#define   SMB_MASTER_CLEAR_BUF			(1 << 3)
+#define   SMB_MASTER_HOLD_RDY			(1 << 5)
+#define   SMB_MASTER_START			(1 << 6)
+#define   SMB_MASTER_EN				(1 << 7)
+
+#define SMBUS_MASTER_CFG2_REG			EC_PAGE_REG(4, 0x61)
+#define   SMB_MASTER_PORT_SEL_MASK		0x03
+#define     SMB_MASTER_PORT(x)			((x) << 0)
+#define     SMB_MASTER_PEC_EN			(1 << 3)
+
+#define SMBUS_MASTER_BAUD_RATE_SEL_REG		EC_PAGE_REG(4, 0x62)
+#define   SMB_MASTER_BAUD_SEL_MASK		(7 << 4)
+#define      SMB_MASTER_BAUD_12_5K		(0  << 0)
+#define      SMB_MASTER_BAUD_25K		(1  << 0)
+#define      SMB_MASTER_BAUD_50K		(2  << 0)
+#define      SMB_MASTER_BAUD_100K		(3  << 0)
+#define      SMB_MASTER_BAUD_200K		(4  << 0)
+#define      SMB_MASTER_BAUD_400K		(5  << 0)
+#define      SMB_MASTER_BAUD_800K		(6  << 0)
+#define      SMB_MASTER_BAUD_1200K		(7  << 0)
+
+#define SMBUS_MASTER_PROTOCOL_SEL_REG		EC_PAGE_REG(4, 0x63)
+#define   SMBUS_MASTER_QUICK_WRITE		0x00
+#define   SMBUS_MASTER_SEND_BYTE		0x01
+#define   SMBUS_MASTER_WRITE_BYTE		0x02
+#define   SMBUS_MASTER_WRITE_WORD		0x03
+#define   SMBUS_MASTER_BLOCK_WRITE		0x04
+#define   SMBUS_MASTER_PROCESS_CALL		0x05
+#define   SMBUS_MASTER_BLOCK_WRITE_READ		0x06
+#define   SMBUS_MASTER_RECEIVE_BYTE		0x81
+#define   SMBUS_MASTER_READ_BYTE		0x82
+#define   SMBUS_MASTER_READ_WORD		0x83
+#define   SMBUS_MASTER_BLOCK_READ		0x84
+
+#define SMBUS_MASTER_BLOCK_WR_LEN_REG		EC_PAGE_REG(4, 0x64)
+#define SMBUS_MASTER_DEV_ADDR_REG		EC_PAGE_REG(4, 0x65)
+#define SMBUS_MASTER_CMD_REG			EC_PAGE_REG(4, 0x66)
+
+#define SMBUS_MASTER_WRITE_BUFFER(x)		EC_PAGE_REG(4, 0x70 + (x))
+#define SMBUS_MASTER_WRITE_BUFFER_LEN		64
+#define SMBUS_MASTER_READ_BUFFER(x)		EC_PAGE_REG(4, 0xb0 + (x))
+#define SMBUS_MASTER_READ_BUFFER_LEN		64
+
+/* EC page 5 - PECI */
+
+#define PECI_PING_INFO_REG			EC_PAGE_REG(5, 0x00)
+#define   PECI_AGENT_ALIVE(agent)		(1 << (agent))
+#define   PECI_OVER_SMBUS			(1 << 7)
+
+#define PECI_INFO_STS_REG			EC_PAGE_REG(5, 0x01)
+#define   PECI_AGENT_INFO_RDY(agent)		(1 << (agent))
+
+#define PECI_DEVICE_INFO_REG			EC_PAGE_REG(5, 0x02)
+#define   PECI_AGENT_TWO_DOMAIN_SUPPORT		(1 << 2)
+
+#define PECI_REVISION_INFO_REG			EC_PAGE_REG(5, 0x03)
+#define   PECI_REV_MINOR_MASK			0x0f
+#define   PECI_REV_MINOR_SHIFT			0
+#define   PECI_REV_MAJOR_MASK			0xf0
+#define   PECI_REV_MAJOR_SHIFT			4
+
+#define PECI_DOM0_MARGIN_HI_REG(agent)		EC_PAGE_REG(5, 0x20 + 2*(agent))
+#define PECI_DOM0_MARGIN_LO_REG(agent)		EC_PAGE_REG(5, 0x21 + 2*(agent))
+#define PECI_DOM1_MARGIN_HI_REG(agent)		EC_PAGE_REG(5, 0x28 + 2*(agent))
+#define PECI_DOM1_MARGIN_LO_REG(agent)		EC_PAGE_REG(5, 0x29 + 2*(agent))
+
+#define PECI_DOM0_TEMP_HI_REG(agent)		EC_PAGE_REG(5, 0x30 + 2*(agent))
+#define PECI_DOM0_TEMP_LO_REG(agent)		EC_PAGE_REG(5, 0x31 + 2*(agent))
+#define PECI_DOM1_TEMP_HI_REG(agent)		EC_PAGE_REG(5, 0x38 + 2*(agent))
+#define PECI_DOM1_TEMP_LO_REG(agent)		EC_PAGE_REG(5, 0x39 + 2*(agent))
+
+#define PECI_TCONTROL_REG(dom, agent)		EC_PAGE_REG(5, 0x40 + 4*(dom) + (agent))
+#define PECI_TJMAX_REG(dom, agent)		EC_PAGE_REG(5, 0x48 + 4*(dom) + (agent))
+
+#define PECI_PCS_ERR_STS_REG			EC_PAGE_REG(5, 0x52)
+#define PECI_MASTER_ERR_STS_REG			EC_PAGE_REG(5, 0x53)
+
+#define PECI_CFG_REG				EC_PAGE_REG(5, 0x60)
+#define   PECI_SPEED_SEL_MASK			(3 << 0)
+#define     PECI_SPEED_2MHZ			(0 << 0)
+#define     PECI_SPEED_1_2MHZ			(1 << 0)
+#define     PECI_SPEED_800KHZ			(2 << 0)
+#define     PECI_SPEED_400KHZ			(3 << 0)
+#define   PECI_USER_TJMAX_FROM_CPU		(0 << 5)
+#define   PECI_USER_TJMAX_FROM_EC		(1 << 5)
+#define   PECI_AGENT_INIT			(1 << 6)
+#define   PECI_EN				(1 << 7)
+
+#define PECI_AGENT_EN_REG			EC_PAGE_REG(5, 0x61)
+#define   PECI_AGENT_EN_MASK			0xf
+#define   PECI_AGENT_EN(agent)			(1 << (agent))
+
+#define PECI_HOSTID_REG				EC_PAGE_REG(5, 0x62)
+#define PECI_ERR_RETRY_CFG_REG			EC_PAGE_REG(5, 0x63)
+#define PECI_MARGIN_CFG_REG			EC_PAGE_REG(5, 0x64)
+#define   PECI_MARGIN_POLLRATE_MASK		0x07
+#define     PECI_MARGIN_POLLRATE_ONCE		(0 << 0)
+#define     PECI_MARGIN_POLLRATE_100MS		(1 << 0)
+#define     PECI_MARGIN_POLLRATE_200MS		(2 << 0)
+#define     PECI_MARGIN_POLLRATE_400MS		(3 << 0)
+#define     PECI_MARGIN_POLLRATE_800MS		(4 << 0)
+#define     PECI_MARGIN_POLLRATE_1S		(5 << 0)
+#define     PECI_MARGIN_POLLRATE_2S		(6 << 0)
+#define     PECI_MARGIN_POLLRATE_4S		(7 << 0)
+#define   PECI_GET_MARGIN_EN			(1 << 7)
+
+#define PECI_USER_TJMAX_REG(dom, agent)		EC_PAGE_REG(5, 0x68 + 4*(dom) + (agent))
+#define PECI_PCS_CFG_REG			0x70
+#define   PECI_PCS_POLLRATE_MASK		0x07
+#define     PECI_PCS_POLLRATE_ONCE		(0 << 0)
+#define     PECI_PCS_POLLRATE_100MS		(1 << 0)
+#define     PECI_PCS_POLLRATE_200MS		(2 << 0)
+#define     PECI_PCS_POLLRATE_400MS		(3 << 0)
+#define     PECI_PCS_POLLRATE_800MS		(4 << 0)
+#define     PECI_PCS_POLLRATE_1S		(5 << 0)
+#define     PECI_PCS_POLLRATE_2S		(6 << 0)
+#define     PECI_PCS_POLLRATE_4S		(7 << 0)
+#define   PECI_PCS_STOP_ERR			(1 << 4)
+#define   PECI_PCS_HOLD_RDY			(1 << 5)
+#define   PECI_PCS_START			(1 << 6)
+#define   PECI_PCS_EN				(1 << 7)
+
+#define PECI_PCS_CFG2_REG			EC_PAGE_REG(5, 0x71)
+#define   PECI_PCS_AGENT_SEL_MASK		0x03
+#define   PECI_PCS_SEL_DOM0			(0 << 4)
+#define   PECI_PCS_SEL_DOM1			(1 << 4)
+#define   PECI_PCS_WRITE_PKG_CFG		(1 << 7)
+
+#define PECI_PCS_IDX_REG			EC_PAGE_REG(5, 0x72)
+#define PECI_PCS_PARAM_LO_REG			EC_PAGE_REG(5, 0x73)
+#define PECI_PCS_PARAM_HI_REG			EC_PAGE_REG(5, 0x74)
+
+#define PECI_PCS_COMPLETION_CODE_REG		EC_PAGE_REG(5, 0x75)
+#define   PECI_PCS_DATA_VALID			0x40
+#define   PECI_PCS_RESP_TIMEOUT_RETRY		0x80
+#define   PECI_PCS_RESP_TIMEOUT			0x81
+#define   PECI_PCS_INVALID_REQUEST		0x90
+#define   PECI_PCS_PECI_CONTROL_HW		0x91
+
+#define PECI_PCS_BUF_REG(x)			EC_PAGE_REG(5, 0x76 + (x))
+#define PECI_PCS_BUF_LEN			4
+
+#define PECI_MASTER_CFG_REG			EC_PAGE_REG(5, 0x7a)
+#define   PECI_MASTER_POLLRATE_MASK		0x07
+#define     PECI_MASTER_POLLRATE_ONCE		(0 << 0)
+#define     PECI_MASTER_POLLRATE_100MS		(1 << 0)
+#define     PECI_MASTER_POLLRATE_200MS		(2 << 0)
+#define     PECI_MASTER_POLLRATE_400MS		(3 << 0)
+#define     PECI_MASTER_POLLRATE_800MS		(4 << 0)
+#define     PECI_MASTER_POLLRATE_1S		(5 << 0)
+#define     PECI_MASTER_POLLRATE_2S		(6 << 0)
+#define     PECI_MASTER_POLLRATE_4S		(7 << 0)
+#define   PECI_MASTER_STOP_ERR			(1 << 4)
+#define   PECI_MASTER_HOLD_RDY			(1 << 5)
+#define   PECI_MASTER_START			(1 << 6)
+#define   PECI_MASTER_EN			(1 << 7)
+
+#define PECI_MASTER_CFG2_REG			EC_PAGE_REG(5, 0x7b)
+#define   PECI_MASTER_CPL_CODE_SUPP		(1 << 6)
+#define   PECI_MASTER_AWFCS_EN			(1 << 7)
+
+#define PECI_MASTER_CLIENT_ADDR_REG		EC_PAGE_REG(5, 0x7c)
+#define PECI_MASTER_CMD_CODE_REG		EC_PAGE_REG(5, 0x7d)
+#define PECI_MASTER_WRITE_LEN_REG		EC_PAGE_REG(5, 0x7e)
+#define PECI_MASTER_READ_LEN_REG		EC_PAGE_REG(5, 0x7f)
+
+#define PECI_MASTER_WRITE_BUF(x)		EC_PAGE_REG(5, 0x80 + (x))
+#define PECI_MASTER_WRITE_BUF_LEN		12
+#define PECI_MASTER_READ_BUF(x)			EC_PAGE_REG(5, 0x90 + (x))
+#define PECI_MASTER_READ_BUF_LEN		12
+
+#define PECI_DRAM_TEMP_WR_STS_REG(x)		EC_PAGE_REG(5, 0xa0 + (x))
+#define PECI_DIMM_AMB_TEMP_WR_STS_REG(x)	EC_PAGE_REG(5, 0xa4 + (x))
+#define PECI_DIMM_TEMP_RD_STS_REG(x)		EC_PAGE_REG(5, 0xa8 + (x))
+#define PECI_ACC_ENERGRY_RD_STS_REG(x)		EC_PAGE_REG(5, 0xac + (x))
+
+#define PECI_DRAM_TEMP_WR_POLL_RATE_REG		EC_PAGE_REG(5, 0xb0)
+#define   PECI_DRAM_POLLRATE_MASK		0x07
+#define     PECI_DRAM_POLLRATE_ONCE		(0 << 0)
+#define     PECI_DRAM_POLLRATE_100MS		(1 << 0)
+#define     PECI_DRAM_POLLRATE_200MS		(2 << 0)
+#define     PECI_DRAM_POLLRATE_400MS		(3 << 0)
+#define     PECI_DRAM_POLLRATE_800MS		(4 << 0)
+#define     PECI_DRAM_POLLRATE_1S		(5 << 0)
+#define     PECI_DRAM_POLLRATE_2S		(6 << 0)
+#define     PECI_DRAM_POLLRATE_4S		(7 << 0)
+
+#define PECI_DIMM_AMB_TEMP_WR_POLL_RATE_REG	EC_PAGE_REG(5, 0xb1)
+#define   PECI_DIMM_AMB_POLLRATE_MASK		0x07
+#define     PECI_DIMM_AMB_POLLRATE_ONCE		(0 << 0)
+#define     PECI_DIMM_AMB_POLLRATE_100MS	(1 << 0)
+#define     PECI_DIMM_AMB_POLLRATE_200MS	(2 << 0)
+#define     PECI_DIMM_AMB_POLLRATE_400MS	(3 << 0)
+#define     PECI_DIMM_AMB_POLLRATE_800MS	(4 << 0)
+#define     PECI_DIMM_AMB_POLLRATE_1S		(5 << 0)
+#define     PECI_DIMM_AMB_POLLRATE_2S		(6 << 0)
+#define     PECI_DIMM_AMB_POLLRATE_4S		(7 << 0)
+
+#define PECI_ACC_ENERGRY_RD_POLL_RATE_REG	EC_PAGE_REG(5, 0xb2)
+#define   PECI_ACC_ENERGRY_RD_POLLRATE_MASK	0x07
+#define     PECI_ACC_ENERGRY_RD_POLLRATE_ONCE	(0 << 0)
+#define     PECI_ACC_ENERGRY_RD_POLLRATE_100MS	(1 << 0)
+#define     PECI_ACC_ENERGRY_RD_POLLRATE_200MS	(2 << 0)
+#define     PECI_ACC_ENERGRY_RD_POLLRATE_400MS	(3 << 0)
+#define     PECI_ACC_ENERGRY_RD_POLLRATE_800MS	(4 << 0)
+#define     PECI_ACC_ENERGRY_RD_POLLRATE_1S	(5 << 0)
+#define     PECI_ACC_ENERGRY_RD_POLLRATE_2S	(6 << 0)
+#define     PECI_ACC_ENERGRY_RD_POLLRATE_4S	(7 << 0)
+
+#define PECI_DRAM_TEMP_WR_CFG1_REG(x)		EC_PAGE_REG(5, 0xb8 + 2*(x))
+#define   PECI_DRAM_TEMP_WR_CH_IDX_MASK		(7 << 0)
+#define   PECI_DRAM_TEMP_WR_CH_IDX_SHIFT	0
+#define   PECI_DRAM_TEMP_WR_DIMM_IDX_MASK	(7 << 3)
+#define   PECI_DRAM_TEMP_WR_DIMM_IDX_SHIFT	3
+#define   PECI_DRAM_TEMP_WR_POLLING		(1 << 6)
+#define   PECI_DRAM_TEMP_WR_START		(1 << 7)
+
+#define PECI_DRAM_TEMP_WR_CFG2_REG(x)		EC_PAGE_REG(5, 0xb9 + 2*(x))
+#define   PECI_DRAM_TEMP_WR_AGENT_IDX_MASK	(3 << 1)
+#define   PECI_DRAM_TEMP_WR_AGENT_IDX_SHIFT	1
+#define   PECI_DRAM_TEMP_WR_DOM0		(0 << 6)
+#define   PECI_DRAM_TEMP_WR_DOM1		(1 << 6)
+#define   PECI_DRAM_TEMP_WR_CH_SEL		(1 << 7)
+
+#define PECI_DIMM_AMB_TEMP_WR_CFG1_REG(x)	EC_PAGE_REG(5, 0xc0 + 2*(x))
+#define   PECI_DIMM_AMB_TEMP_WR_CH_IDX_MASK	(7 << 0)
+#define   PECI_DIMM_AMB_TEMP_WR_CH_IDX_SHIFT	0
+#define   PECI_DIMM_AMB_TEMP_WR_POLLING		(1 << 6)
+#define   PECI_DIMM_AMB_TEMP_WR_START		(1 << 7)
+
+#define PECI_DIMM_AMB_TEMP_WR_CFG2_REG(x)	EC_PAGE_REG(5, 0xc1 + 2*(x))
+#define   PECI_DIMM_AMB_TEMP_WR_AGENT_IDX_MASK	(3 << 1)
+#define   PECI_DIMM_AMB_TEMP_WR_AGENT_IDX_SHIFT	1
+#define   PECI_DIMM_AMB_TEMP_WR_DOM0		(0 << 6)
+#define   PECI_DIMM_AMB_TEMP_WR_DOM1		(1 << 6)
+#define   PECI_DIMM_AMB_TEMP_WR_CH_SEL		(1 << 7)
+
+#define PECI_DIMM_TEMP_RD_CFG1_REG(x)		EC_PAGE_REG(5, 0xc8 + (x))
+#define   PECI_DIMM_TEMP_RD_AGENT_IDX_MASK	(3 << 0)
+#define   PECI_DIMM_TEMP_RD_AGENT_IDX_SHIFT	0
+#define   PECI_DIMM_TEMP_RD_DOM0		(0 << 2)
+#define   PECI_DIMM_TEMP_RD_DOM1		(1 << 2)
+#define   PECI_DIMM_TEMP_RD_DIMM_SEL_MASK	(3 << 4)
+#define     PECI_DIMM_TEMP_RD_DIMM0		(0 << 4)
+#define     PECI_DIMM_TEMP_RD_DIMM1		(1 << 4)
+#define     PECI_DIMM_TEMP_RD_DIMM0_MAX		(2 << 4)
+#define     PECI_DIMM_TEMP_RD_DIMM1_MAX		(3 << 4)
+#define   PECI_DIMM_TEMP_RD_DIMM_CH0		(0 << 6)
+#define   PECI_DIMM_TEMP_RD_DIMM_CH1		(1 << 6)
+
+#define PECI_ACC_ENERGRY_RD_CFG_REG(x)		EC_PAGE_REG(5, 0xcc + (x))
+#define   PECI_ACC_ENERGRY_RD_AGENT_IDX_MASK	(3 << 0)
+#define   PECI_ACC_ENERGRY_RD_AGENT_IDX_SHIFT	0
+#define   PECI_ACC_ENERGRY_RD_DOM0		(0 << 2)
+#define   PECI_ACC_ENERGRY_RD_DOM1		(1 << 2)
+#define   PECI_ACC_ENERGRY_RD_REPORT_CURR	(0 << 3)
+#define   PECI_ACC_ENERGRY_RD_REPORT_INCR	(1 << 3)
+#define   PECI_DIMM_TEMP_RD_PWR_PLANE_SEL_MASK	(3 << 4)
+#define     PECI_DIMM_TEMP_RD_PWR_PLANE0	(0 << 4)
+#define     PECI_DIMM_TEMP_RD_PWR_PLANE1	(1 << 4)
+#define     PECI_DIMM_TEMP_RD_PKG_PWR_PLANE0	(2 << 4)
+#define     PECI_DIMM_TEMP_RD_PKG_PWR_PLANE1	(3 << 4)
+#define     PECI_ACC_ENERGRY_RD_POLLING		(1 << 6)
+#define     PECI_ACC_ENERGRY_RD_START		(1 << 7)
+
+#define PECI_ACC_ENERGRY_RD_VAL_B0_REG(x)	EC_PAGE_REG(5, 0xd0 + 4*(x))
+#define PECI_ACC_ENERGRY_RD_VAL_B1_REG(x)	EC_PAGE_REG(5, 0xd1 + 4*(x))
+#define PECI_ACC_ENERGRY_RD_VAL_B2_REG(x)	EC_PAGE_REG(5, 0xd2 + 4*(x))
+#define PECI_ACC_ENERGRY_RD_VAL_B3_REG(x)	EC_PAGE_REG(5, 0xd3 + 4*(x))
+
+/* EC Page 6 - EC FW Information and Configuration */
+
+#define CHIP_ID0_REG				EC_PAGE_REG(6, 0x00)
+#define CHIP_ID1_REG				EC_PAGE_REG(6, 0x01)
+#define CUSTOMER_ID0_REG			EC_PAGE_REG(6, 0x02)
+#define CUSTOMER_ID1_REG			EC_PAGE_REG(6, 0x03)
+#define FW_BUILD_YEAR_REG			EC_PAGE_REG(6, 0x04)
+#define FW_BUILD_MONTH_REG			EC_PAGE_REG(6, 0x05)
+#define FW_BUILD_DAY_REG			EC_PAGE_REG(6, 0x06)
+#define FW_BUILD_SERIALNUM_REG			EC_PAGE_REG(6, 0x07)
+#define FW_VER0_REG				EC_PAGE_REG(6, 0x08)
+#define FW_VER1_REG				EC_PAGE_REG(6, 0x09)
+#define PROFILE_VER_REG				EC_PAGE_REG(6, 0x0a)
+#define ROM_VER0_REG				EC_PAGE_REG(6, 0x0c)
+#define ROM_VER1_REG				EC_PAGE_REG(6, 0x0d)
+#define ROM_VER2_REG				EC_PAGE_REG(6, 0x0e)
+#define ROM_VER3_REG				EC_PAGE_REG(6, 0x0f)
+#define ISP_BUILD_YEAR_REG			EC_PAGE_REG(6, 0x12)
+#define ISP_BUILD_MONTH_REG			EC_PAGE_REG(6, 0x13)
+#define ISP_BUILD_DAY_REG			EC_PAGE_REG(6, 0x14)
+#define ISP_BUILD_SERIALNUM_REG			EC_PAGE_REG(6, 0x15)
+#define ISP_VER0_REG				EC_PAGE_REG(6, 0x16)
+#define ISP_VER1_REG				EC_PAGE_REG(6, 0x17)
+
+#define OEM_VER_REG				EC_PAGE_REG(6, 0x18)
+#define   OEM_VER_LEN				8
+
+#define EC_ALIVE_COUNTER_REG			EC_PAGE_REG(6, 0x20)
+
+#define EC_HEARTBEAT_CFG_REG			EC_PAGE_REG(6, 0x2e)
+#define   EC_HEARBEAT_TOGGLE_RATE_MASK		0x0f
+#define   EC_HEARBEAT_TYPE_OD			(0 << 6)
+#define   EC_HEARBEAT_TYPE_PP			(1 << 6)
+#define   EC_HEARBEAT_EN			(1 << 7)
+
+#define EC_HEARTBEAT_GPSEL_REG			EC_PAGE_REG(6, 0x2f)
+#define   EC_HEARBEAT_GPIO_PIN_MASK		0x0f
+#define   EC_HEARBEAT_GPIO_PIN_SHIFT		0
+#define   EC_HEARBEAT_GPIO_GROUP_MASK		0xf0
+#define   EC_HEARBEAT_GPIO_GROUP_SHIFT		4
+
+#define EC_MCU_SPEED_REG			EC_PAGE_REG(6, 0x38)
+#define   EC_MCU_SPEED_MCLK_MASK		0x0f
+#define     EC_MCU_SPEED_MCLK_10KHZ		(0 << 0)
+#define     EC_MCU_SPEED_MCLK_160KHZ		(1 << 0)
+#define     EC_MCU_SPEED_MCLK_1MHZ		(2 << 0)
+#define     EC_MCU_SPEED_MCLK_4MHZ		(3 << 0)
+#define     EC_MCU_SPEED_MCLK_8MHZ		(4 << 0)
+#define     EC_MCU_SPEED_MCLK_16MHZ		(5 << 0)
+#define     EC_MCU_SPEED_MCLK_24MHZ		(6 << 0)
+#define     EC_MCU_SPEED_MCLK_48MHZ		(7 << 0)
+#define   EC_MCU_CACHE_EN			(1 << 6)
+
+#define EC_FLASH_SPEED_REG			EC_PAGE_REG(6, 0x39)
+#define   EC_FLASH_CLK_DIV_MASK			(3 << 4)
+#define     EC_FLASH_CLK_DIV_1			(0 << 4)
+#define     EC_FLASH_CLK_DIV_2			(1 << 4)
+#define     EC_FLASH_CLK_DIV_4			(2 << 4)
+#define     EC_FLASH_CLK_DIV_16			(3 << 4)
+#define   EC_FLASH_FETCH_MODE_MASK		(3 << 6)
+#define     EC_FLASH_FETCH_MODE_READ		(0 << 6)
+#define     EC_FLASH_FETCH_MODE_FAST_READ	(1 << 6)
+#define     EC_FLASH_FETCH_MODE_DUAL_OUT	(2 << 6)
+#define     EC_FLASH_FETCH_MODE_DUAL_IN_OUT	(3 << 6)
+
+#define EC_FLASH_MANUFACTURE_REG		EC_PAGE_REG(6, 0x3a)
+#define EC_FLASH_MEMORY_TYPE_REG		EC_PAGE_REG(6, 0x3b)
+#define EC_FLASH_CAPACITY_REG			EC_PAGE_REG(6, 0x3c)
+
+#define EC_MCU_SPEED_CTL_VSB_REG		EC_PAGE_REG(6, 0x40)
+#define   EC_FLASH_CLK_VSB_DIV_MASK		(3 << 0)
+#define     EC_FLASH_CLK_VSB_DIV_1		(0 << 0)
+#define     EC_FLASH_CLK_VSB_DIV_2		(1 << 0)
+#define     EC_FLASH_CLK_VSB_DIV_4		(2 << 0)
+#define     EC_FLASH_CLK_VSB_DIV_16		(3 << 0)
+#define   EC_FLASH_FETCH_MODE_VSB_MASK		(3 << 2)
+#define     EC_FLASH_FETCH_MODE_VSB_READ	(0 << 2)
+#define     EC_FLASH_FETCH_MODE_VSB_FAST_READ	(1 << 2)
+#define     EC_FLASH_FETCH_MODE_VSB_DUAL_OUT	(2 << 2)
+#define     EC_FLASH_FETCH_MODE_VSB_DUAL_IN_OUT	(3 << 2)
+#define   EC_MCU_SPEED_MCLK_VSB_MASK		(3 << 4)
+#define     EC_MCU_SPEED_MCLK_VSB_1MHZ		(0 << 4)
+#define     EC_MCU_SPEED_MCLK_VSB_4MHZ		(1 << 4)
+#define     EC_MCU_SPEED_MCLK_VSB_24MHZ		(2 << 4)
+#define     EC_MCU_SPEED_MCLK_VSB_48MHZ		(3 << 4)
+#define   EC_MCU_CACHE_VSB_EN			(1 << 6)
+
+#define EC_MCU_SPEED_CTL_VCC_REG		EC_PAGE_REG(6, 0x42)
+#define   EC_MCU_SPEED_MCLK_VCC_MASK		0x0f
+#define     EC_MCU_SPEED_MCLK_VCC_10KHZ		(0 << 0)
+#define     EC_MCU_SPEED_MCLK_VCC_160KHZ	(1 << 0)
+#define     EC_MCU_SPEED_MCLK_VCC_1MHZ		(2 << 0)
+#define     EC_MCU_SPEED_MCLK_VCC_4MHZ		(3 << 0)
+#define     EC_MCU_SPEED_MCLK_VCC_8MHZ		(4 << 0)
+#define     EC_MCU_SPEED_MCLK_VCC_16MHZ		(5 << 0)
+#define     EC_MCU_SPEED_MCLK_VCC_24MHZ		(6 << 0)
+#define     EC_MCU_SPEED_MCLK_VCC_48MHZ		(7 << 0)
+#define   EC_MCU_CACHE_VCC_EN			(1 << 6)
+#define   EC_MCU_SPEED_VCC_LOAD_CFG		(1 << 7)
+
+#define EC_FLASH_SPEED_CTL_VCC_REG		EC_PAGE_REG(6, 0x43)
+#define   EC_FLASH_CLK_VCC_DIV_MASK		(3 << 2)
+#define     EC_FLASH_CLK_VCC_DIV_1		(0 << 2)
+#define     EC_FLASH_CLK_VCC_DIV_2		(1 << 2)
+#define     EC_FLASH_CLK_VCC_DIV_4		(2 << 2)
+#define     EC_FLASH_CLK_VCC_DIV_16		(3 << 2)
+#define   EC_FLASH_FETCH_MODE_VCC_MASK		(3 << 4)
+#define     EC_FLASH_FETCH_MODE_VCC_READ	(0 << 4)
+#define     EC_FLASH_FETCH_MODE_VCC_FAST_READ	(1 << 4)
+#define     EC_FLASH_FETCH_MODE_VCC_DUAL_OUT	(2 << 4)
+#define     EC_FLASH_FETCH_MODE_VCC_DUAL_IN_OUT	(3 << 4)
+#define   EC_FLASH_SPEED_VCC_LOAD_CFG		(1 << 7)
+
+#define EC_FLASH_WREN_CMD_REG			EC_PAGE_REG(6, 0x47)
+
+#define EC_FLASH_WRITE_LOCK_REG			EC_PAGE_REG(6, 0x4f)
+#define   EC_FLASH_WRITE_LOCK			(1 << 0)
+#define   EC_FLASH_WRITE_LOCK_EN		(1 << 7)
+
+/* EC Page 8 - NCT6687D specific, not present in NCT6686D */
+
+#define FAN9_FAN10_MANUAL_EN_REG		EC_PAGE_REG(8, 0x0f)
+
+#define FAN_STEP_UP_TIME_REG(fan)		EC_PAGE_REG(8, 0x1a + ((fan) - 1))
+#define FAN_STEP_DOWN_TIME_REG(fan)		EC_PAGE_REG(8, 0x24 + ((fan) - 1))
+
+/* These are also included in macros in page 1, 10 and 12 */
+#define FAN9_FUNCTION_CTL_REG			EC_PAGE_REG(8, 0xe0)
+#define FAN10_FUNCTION_CTL_REG			EC_PAGE_REG(8, 0xe1)
+#define FAN9_MANUAL_OUTPUT_VAL_REG		EC_PAGE_REG(8, 0xe8)
+#define FAN10_MANUAL_OUTPUT_VAL_REG		EC_PAGE_REG(8, 0xe9)
+#define FAN9_DUTY_REG				EC_PAGE_REG(8, 0xf0)
+#define FAN10_DUTY_REG				EC_PAGE_REG(8, 0xf1)
+#define	FAN9OUT_CFG_REG				EC_PAGE_REG(8, 0xf4)
+#define	FAN10OUT_CFG_REG			EC_PAGE_REG(8, 0xf5)
+
+/* EC Page 9 - Fan Algorithm Function Control */
+
+#define FAN_ALG_FUNCTRL_REG(fan)		EC_PAGE_REG(9, 0x00 + ((fan) - 1))
+#define   FAN_ALG_FUNCTRL_DTS_UB_EN		(1 << 2)
+#define   FAN_ALG_FUNCTRL_DTS2_EN		(1 << 3)
+#define   FAN_ALG_FUNCTRL_DTS1_EN		(1 << 4)
+#define   FAN_ALG_FUNCTRL_TEMP_ERR		(1 << 5)
+#define   FAN_ALG_FUNCTRL_CRIT_TEMP_EN		(1 << 6)
+#define   FAN_ALG_FUNCTRL_ALG_EN		(1 << 7)
+
+/* Main temperature zone decision */
+#define FAN_MTZ_DCS_DATA_REG(x, fan)		EC_PAGE_REG(9, 0x10 + (x) + 4*((fan) - 1))
+/* Ambient temperature zone decision */
+#define FAN_ATZ_DCS_DATA_REG(x, fan)		EC_PAGE_REG(9, 0x50 + (x) 4*((fan) - 1))
+
+#define FAN_INITIAL_VALUE_REG(fan)		EC_PAGE_REG(9, 0x90 + ((fan) - 1))
+#define FAN_CRIT_TEMP_CFG_REG(fan)		EC_PAGE_REG(9, 0xA0 + ((fan) - 1))
+#define FAN_CRIT_TEMP_TOLERANCE_REG(fan)	EC_PAGE_REG(9, 0xB0 + ((fan) - 1))
+#define FAN_TEMP_ERR_DUTY_VAL_REG(fan)		EC_PAGE_REG(9, 0xC0 + ((fan) - 1))
+
+#define FAN_MODE_SEL_REG(fan)			EC_PAGE_REG(9, 0xD0 + ((fan) - 1))
+#define   FAN_MODE_SEL_MASK			0xf
+#define     FAN_MODE_MODE_MANUAL		(0 << 0)
+#define     FAN_MODE_THERMAL_CRUISE		(1 << 0)
+#define     FAN_MODE_SPEED_CRUISE		(2 << 0)
+#define     FAN_MODE_SMART_FAN_IV		(3 << 0)
+#define     FAN_MODE_PID_CONTROL		(4 << 0)
+
+/* EC Page 10 - Fan Function Control & Weight Matrix */
+
+#define FAN_MANUAL_EN_REG(fan) \
+	(((fan) > 8)	? EC_PAGE_REG(8, 0x0f) \
+			: EC_PAGE_REG(10, 0x00))
+#define   FAN_MANUAL_EN(fan)			(1 << (((fan) - 1) % 8))
+
+#define FAN_CFG_CTRL_REG			EC_PAGE_REG(10, 0x01)
+#define   FAN_CFG_DONE				(1 << 6)
+#define   FAN_CFG_REQUEST			(1 << 7)
+
+#define FAN_FUNCTION_CTRL(fan) \
+	(((fan) > 8)	? EC_PAGE_REG(8, 0xe0 + ((fan) - 9)) \
+			: EC_PAGE_REG(10, 0x08 + ((fan) - 1)))
+#define   FAN_FUN_MINDUTY_EN			(1 << 0)
+#define   FAN_FUN_MANUAL_OFFSET_EN		(1 << 1)
+#define   FAN_FUN_STARTUP_EN			(1 << 2)
+#define   FAN_FUN_AMBIENT_FLOOR_EN		(1 << 3)
+#define   FAN_FUN_MARKUP_TRACK_EN		(1 << 4)
+#define   FAN_FUN_FAST_TRACK_EN			(1 << 5)
+#define   FAN_FUN_SMART_TRACK_EN		(1 << 6)
+#define   FAN_FUN_UNIT_PWM_DUTY			(0 << 7)
+#define   FAN_FUN_UNIT_RPM			(1 << 7)
+
+/* The unit for below Ambient Floor register is 100 RPM */
+#define FAN_AMB_FLOOR_RPM_TO_REG(rpm)		((rpm) ? (rpm) / 100 : 1)
+#define FAN_AMB_FLOOR_MIN_OUT_START_REG(fan)	EC_PAGE_REG(10, 0x10 + ((fan) - 1))
+#define FAN_AMB_FLOOR_MIN_OUT_END_REG(fan)	EC_PAGE_REG(10, 0x18 + ((fan) - 1))
+#define FAN_AMB_FLOOR_MAX_OUT_REG(fan)		EC_PAGE_REG(10, 0x20 + ((fan) - 1))
+
+#define FAN_MANUAL_VALUE_REG(fan) \
+	(((fan) > 8)	? EC_PAGE_REG(8, 0xe8 + ((fan) - 9)) \
+			: EC_PAGE_REG(10, 0x28 + ((fan) - 1)))
+
+#define FAN_MANUAL_OFFSET_REG(fan)		EC_PAGE_REG(10, 0x30 + ((fan) - 1))
+#define FAN_MIN_DUTY_REG(fan)			EC_PAGE_REG(10, 0x38 + ((fan) - 1))
+#define FAN_STARTUP_DUTY_REG(fan)		EC_PAGE_REG(10, 0x40 + ((fan) - 1))
+
+/* Smart Tracking registers */
+
+#define FAN_LOW_RPM_SPEED_BOUNDARY_HI_REG	EC_PAGE_REG(10, 0x48)
+#define FAN_LOW_RPM_SPEED_BOUNDARY_LO_REG	EC_PAGE_REG(10, 0x49)
+#define FAN_HIGH_RPM_SPEED_BOUNDARY_HI_REG	EC_PAGE_REG(10, 0x4a)
+#define FAN_HIGH_RPM_SPEED_BOUNDARY_LO_REG	EC_PAGE_REG(10, 0x4b)
+
+#define FAN_LOW_RPM_TOLERANCE_REG		EC_PAGE_REG(10, 0x4c)
+#define FAN_MID_RPM_TOLERANCE_REG		EC_PAGE_REG(10, 0x4d)
+#define FAN_HIGH_RPM_TOLERANCE_REG		EC_PAGE_REG(10, 0x4e)
+
+#define FAN_TRACKING_STEP_REG			EC_PAGE_REG(10, 0x4f)
+#define   FAN_TRACK_STEP_DOWN_MASK		0x0f
+#define   FAN_TRACK_STEP_DOWN_SHIFT		0
+#define   FAN_TRACK_STEP_UP_MASK		0x0f
+#define   FAN_TRACK_STEP_UP_SHIFT		4
+
+#define FAN_FAST_TRACK_TEMP_BOUNDARY_REG	EC_PAGE_REG(10, 0x50)
+
+/* Below definitions are dividers for fast tracking weight registers */
+#define FAN_FAST_TRACK_WEIGHT_DIV_1		1
+#define FAN_FAST_TRACK_WEIGHT_DIV_2		2
+#define FAN_FAST_TRACK_WEIGHT_DIV_4		3
+#define FAN_FAST_TRACK_WEIGHT_DIV_8		4
+#define FAN_FAST_TRACK_WEIGHT_DIV_16		5
+#define FAN_FAST_TRACK_WEIGHT_DIV_32		6
+#define FAN_FAST_TRACK_WEIGHT_DIV_64		7
+
+/* Below definitions are shifts and masks for fast tracking weight registers */
+#define FAN_FAST_TRACK_WEIGHT_DOWN_MASK		0x07
+#define FAN_FAST_TRACK_WEIGHT_DOWN_SHIFT	0
+#define FAN_FAST_TRACK_WEIGHT_UP_MASK		0x07
+#define FAN_FAST_TRACK_WEIGHT_UP_SHIFT		4
+
+#define FAN_LOW_RPM_FAST_TRACK_WEIGHT_REG	EC_PAGE_REG(10, 0x51)
+#define FAN_MID_RPM_FAST_TRACK_WEIGHT_REG	EC_PAGE_REG(10, 0x52)
+#define FAN_HIGH_RPM_FAST_TRACK_WEIGHT_REG	EC_PAGE_REG(10, 0x53)
+
+/* Below definitions are shifts and masks for fast tracking duty step registers */
+#define   FAN_FAST_TRACK_DUTY_STEP_MASK		0x0f
+#define   FAN_FAST_TRACK_DUTY_STEP_SHIFT	0
+
+#define FAN_LOW_RPM_FAST_TRACK_DUTY_STEP_REG	EC_PAGE_REG(10, 0x54)
+#define FAN_MID_RPM_FAST_TRACK_DUTY_STEP_REG	EC_PAGE_REG(10, 0x55)
+#define FAN_HIGH_RPM_FAST_TRACK_DUTY_STEP_REG	EC_PAGE_REG(10, 0x56)
+
+#define FAN_MARKUP_TRACK_AMB_TEMP_BOUNDARY_REG	EC_PAGE_REG(10, 0x57)
+#define FAN_MARKUP_TRACK_WEIGHT_REG		EC_PAGE_REG(10, 0x58)
+#define   FAN_MARKUP_TRACK_WEIGHT_MASK		0x07
+#define   FAN_MARKUP_TRACK_WEIGHT_SHIFT		0
+
+/* Intel Sensor Based (DTS) Fan Control registers */
+
+#define ITL_TEMP_START_POINT_REG		EC_PAGE_REG(10, 0x59)
+#define ITL_TEMP_END_POINT_REG			EC_PAGE_REG(10, 0x5a)
+#define ITL_AMB_TEMP_START_POINT_REG(x)		EC_PAGE_REG(10, 0x5b + (x))
+
+#define ITL_RPM_START_POINT_HI_REG(x)		EC_PAGE_REG(10, 0x60 + 2*(x))
+#define ITL_RPM_START_POINT_LO_REG(x)		EC_PAGE_REG(10, 0x61 + 2*(x))
+#define ITL_RPM_END_POINT_HI_REG(x)		EC_PAGE_REG(10, 0x6a + 2*(x))
+#define ITL_RPM_END_POINT_LO_REG(x)		EC_PAGE_REG(10, 0x6a + 2*(x))
+#define ITL_RPM_MAX_SPEED_HI_REG		EC_PAGE_REG(10, 0x74)
+#define ITL_RPM_MAX_SPEED_LO_REG		EC_PAGE_REG(10, 0x75)
+
+#define ITL_DTS_CFG_REG				EC_PAGE_REG(10, 0x76)
+#define   ITL_DTS_PECI_AGENT_IDX_SEL_MASK	0x0f
+#define   ITL_DTS_PECI_AGENT_IDX_SEL_SHIFT	0
+#define   ITL_DTS_PECI_CFG_ADJUSTMENT		(1 << 7)
+
+#define AMBIENT_FLOOR_TEMP_START_POINT_REG	EC_PAGE_REG(10, 0x77)
+#define AMBIENT_FLOOR_TEMP_END_POINT_REG	EC_PAGE_REG(10, 0x78)
+
+/* DTS 2.0 sensor registers */
+
+#define DTS2_TARGET_MARGIN_REG			EC_PAGE_REG(10, 0x59)
+#define DTS2_TCONTROL_REG			EC_PAGE_REG(10, 0x5a)
+#define DTS2_TCONTROL_OFFSET_REG		EC_PAGE_REG(10, 0x5b)
+#define DTS2_TARGET_TOLERANCE_REG		EC_PAGE_REG(10, 0x5c)
+#define DTS2_DIVISOR_REG			EC_PAGE_REG(10, 0x5d)
+#define DTS2_STEP_SPEED_HI_REG			EC_PAGE_REG(10, 0x5e)
+#define DTS2_STEP_SPEED_LO_REG			EC_PAGE_REG(10, 0x5f)
+#define DTS2_MIN_SPEED_HI_REG			EC_PAGE_REG(10, 0x60)
+#define DTS2_MIN_SPEED_LO_REG			EC_PAGE_REG(10, 0x61)
+#define DTS2_DELAY_TIME_COUNTER_REG		EC_PAGE_REG(10, 0x62)
+
+/* Weight Matrix Configuration */
+
+#define FAN_ALG_ENGINE_WEIGHT_EN_REG(fan) \
+	(((fan) > 8)	? EC_PAGE_REG(10, 0xC1 + 8*((fan) - 9)) \
+			: EC_PAGE_REG(10, 0x80 + 8*((fan) - 1)))
+#define   FAN_ALG_ENGINE_WEIGHT_CHANNEL_EN(fan)	(1 << (((fan) - 1) % 8))
+
+#define FAN_ALG_ENGINE_WEIGHT_VAL_REG(fan) \
+	(((fan) > 8)	? EC_PAGE_REG(10, 0xC3 + ((fan) - 9)/2 + 8*((fan) - 9)) \
+			: EC_PAGE_REG(10, 0x84 + ((fan) - 1)/2 + 8*((fan) - 1)))
+#define   FAN_ALG_ENGINE_WEIGHT_MASK(fan)	(0xf << (4 * (((fan) - 1) % 2)))
+#define   FAN_ALG_ENGINE_WEIGHT_SHIFT(fan)	(4 * (((fan) - 1) % 2))
+
+/* EC Page 11 - Thermal Cruise, Speed Cruise, Smart Fan IV */
+
+#define FAN_PWM_PERCENT_TO_HEX(x)		((x) * 255 / 100)
+
+
+/* For x larger than 10, the registers are placed in page 12 */
+/* Thermal Cruise (TC) Registers */
+
+#define FAN_TC_TARGET_TEMP_TOLERANCE_REG(fan)	EC_PAGE_REG(11, 0x00 + 24*((fan) - 1))
+#define   FAN_TC_TEMP_TOLERANCE_MASK		0xf
+#define   FAN_TC_TEMP_TOLERANCE_SHIFT		0
+
+#define FAN_TC_TARGET_TEMP_REG(fan)		EC_PAGE_REG(11, 0x01 + 24*((fan) - 1))
+#define   FAN_TC_TARGET_TEMP_MASK		0x7f
+#define   FAN_TC_TARGET_TEMP_SHIFT		0
+#define   FAN_TC_KEEP_MIN_OUTPUT		(1 << 7)
+
+#define FAN_TC_STOP_VALUE_REG(fan)		EC_PAGE_REG(11, 0x02 + 24*((fan) - 1))
+
+#define FAN_TC_TIME_TO_SECONDS(x)		((x)*10)
+#define FAN_TC_STOP_TIME_REG(fan)		EC_PAGE_REG(11, 0x03 + 24*((fan) - 1))
+#define FAN_TC_STEP_DOWN_TIME_REG(fan)		EC_PAGE_REG(11, 0x04 + 24*((fan) - 1))
+#define FAN_TC_STEP_UP_TIME_REG(fan)		EC_PAGE_REG(11, 0x05 + 24*((fan) - 1))
+
+/* Speed Cruise (SC) Registers */
+
+#define FAN_SC_TARGET_RPM_HI_REG(fan)		EC_PAGE_REG(11, 0x00 + 24*((fan) - 1))
+#define FAN_SC_TARGET_RPM_LO_REG(fan)		EC_PAGE_REG(11, 0x01 + 24*((fan) - 1))
+#define FAN_SC_TARGET_RPM_TOLERANCE_HI_REG(fan)	EC_PAGE_REG(11, 0x02 + 24*((fan) - 1))
+#define FAN_SC_TARGET_RPM_TOLERANCE_LO_REG(fan)	EC_PAGE_REG(11, 0x03 + 24*((fan) - 1))
+
+#define FAN_SC_TIME_TO_SECONDS(x)		((x)*10)
+#define FAN_SC_STEP_DOWN_TIME_REG(fan)		EC_PAGE_REG(11, 0x04 + 24*((fan) - 1))
+#define FAN_SC_STEP_UP_TIME_REG(fan)		EC_PAGE_REG(11, 0x05 + 24*((fan) - 1))
+
+/* Smart Fan IV (SF4) Registers */
+
+#define FAN_SF4_TEMP_LVL_REG(fan, level)	EC_PAGE_REG(11, 0x00 + (level) + 24*((fan) - 1))
+#define FAN_SF4_PWM_RPM_LVL_HI_REG(fan, level)	EC_PAGE_REG(11, 0x07 + (level)*2 + 24*((fan) - 1))
+#define FAN_SF4_PWM_RPM_LVL_LO_REG(fan, level)	EC_PAGE_REG(11, 0x08 + (level)*2 + 24*((fan) - 1))
+#define FAN_SF4_TEMP_OFF_HYSTHERESIS_REG(fan)	EC_PAGE_REG(11, 0x15 + 24*((fan) - 1))
+#define FAN_SF4_TEMP_CUT_OFF_REG(fan)		EC_PAGE_REG(11, 0x16 + 24*((fan) - 1))
+#define FAN_SF4_TEMP_OFF_DELAY_REG(fan)		EC_PAGE_REG(11, 0x17 + 24*((fan) - 1))
+
+/* EC Page 12 - Fan Function Control */
+
+#define FAN_ENGINE_STS_REG			EC_PAGE_REG(12, 0xf8)
+#define   FAN_PECI_CFG_ADJUSTED			(1 << 1)
+#define   FAN_UNFINISHED_FLAG			(1 << 2)
+#define   FAN_CFG_PHASE				(1 << 3)
+#define   FAN_CFG_INVALID			(1 << 4)
+#define   FAN_CFG_CHECK_DONE			(1 << 5)
+#define   FAN_CFG_LOCK				(1 << 6)
+#define   FAN_DRIVE_BY_MOD_SEL			(0 << 7)
+#define   FAN_DRIVE_BY_DEFAULT_VAL		(1 << 7)
+
+#define FAN_LAST_ERROR_CODE_REG			EC_PAGE_REG(12, 0xf9)
+#define   FAN_NO_ERROR				0x00
+#define   FAN_ERR_MODE_SELECT			0x01
+#define   FAN_ERR_CRIT_TEMP_PROTECT		0x02
+#define   FAN_ERR_ITL_FAN_CONTROL		0x04
+#define   FAN_ERR_SMART_TRACKING		0x05
+#define   FAN_ERR_THERMAL_CRUISE 		0x10
+#define   FAN_ERR_SPEED_CRUISE			0x20
+#define   FAN_ERR_SMART_FAN_IV			0x40
+#define   FAN_ERR_PID_CONTROL			0x50
+
+#define FAN_CHANNEL_EN_REG(fan) \
+	(((fan) > 8)	? EC_PAGE_REG(12, 0xfb) \
+			: EC_PAGE_REG(12, 0xfc))
+#define   FAN_CHANNEL_EN(fan)			(1 << (((fan) - 1) % 8))
+
+#define FAN_DEFAULT_VAL_REG			EC_PAGE_REG(12, 0xfd)
+
+extern uint16_t nct6687d_hwm_base;
+
+static __always_inline void hwm_reg_and_or(uint16_t page_reg, uint8_t and_mask, uint8_t or_mask)
+{
+	assert(nct6687d_hwm_base != 0);
+	nct6687d_ec_and_or_page(nct6687d_hwm_base, page_reg >> 8, page_reg & 0xff,
+				and_mask, or_mask);
+}
+
+static __always_inline void hwm_reg_set_bits(uint16_t page_reg, uint8_t bits)
+{
+	assert(nct6687d_hwm_base != 0);
+	nct6687d_ec_and_or_page(nct6687d_hwm_base, page_reg >> 8, page_reg & 0xff,
+				~bits, bits);
+}
+
+static __always_inline void hwm_reg_write(uint16_t page_reg, uint8_t value)
+{
+	assert(nct6687d_hwm_base != 0);
+	nct6687d_ec_write_page(nct6687d_hwm_base, page_reg >> 8, page_reg & 0xff, value);
+}
+
+static __always_inline uint8_t hwm_reg_read(uint16_t page_reg)
+{
+	assert(nct6687d_hwm_base != 0);
+	return nct6687d_ec_read_page(nct6687d_hwm_base, page_reg >> 8, page_reg & 0xff);
+}
+
+#endif /* SUPERIO_NUVOTON_NCT6687D_HWM_H */
diff --git a/src/superio/nuvoton/nct6687d/superio.c b/src/superio/nuvoton/nct6687d/superio.c
index c28092736f..7c3c496635 100644
--- a/src/superio/nuvoton/nct6687d/superio.c
+++ b/src/superio/nuvoton/nct6687d/superio.c
@@ -7,6 +7,7 @@
 #include <option.h>
 #include <superio/conf_mode.h>
 
+#include "chip.h"
 #include "nct6687d.h"
 
 #define MAINBOARD_POWER_OFF	0
@@ -23,6 +24,9 @@
 
 static void nct6687d_init(struct device *dev)
 {
+	const struct superio_nuvoton_nct6687d_config *conf;
+	const struct resource *res;
+
 	if (!dev->enabled)
 		return;
 
@@ -50,6 +54,12 @@ static void nct6687d_init(struct device *dev)
 		printk(BIOS_INFO, "set power %s after power fail\n",
 		       power_status ? "on" : "off");
 		break;
+	case NCT6687D_EC:
+		conf = dev->chip_info;
+		res = probe_resource(dev, PNP_IDX_IO0);
+		if (!conf || !res)
+			break;
+		nct6687d_hwm_init(res->base, conf);
 	}
 }
 
-- 
2.49.0

